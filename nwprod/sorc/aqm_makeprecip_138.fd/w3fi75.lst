IBM XL Fortran Enterprise Edition V10.1 for AIX (5724-M13)  Version 10.01.0000.0002 --- /gpfs/m/nco/ops/nwpara/sorc/aqm_makeprecip_138.fd/w3fi75.f 11/27/06 09:54:25
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
          1 |      SUBROUTINE W3FI75 (IBITL,ITYPE,ITOSS,FLD,IFLD,IBMAP,IBDSFL,
          2 |     &  NPTS,BDS11,IPFLD,PFLD,LEN,LENBDS,IBERR,PDS,IGDS)
          3 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
          4 |C                .      .    .                                       .
          5 |C SUBPROGRAM:  W3FI75        GRIB PACK DATA AND FORM BDS OCTETS(1-11)
          6 |C   PRGMMR: FARLEY           ORG: NMC421      DATE:94-11-22
          7 |C
          8 |C ABSTRACT: THIS ROUTINE PACKS A GRIB FIELD AND FORMS OCTETS(1-11)
          9 |C   OF THE BINARY DATA SECTION (BDS).
         10 |C
         11 |C PROGRAM HISTORY LOG:
         12 |C   92-07-10  M. FARLEY   ORIGINAL AUTHOR
         13 |C   92-10-01  R.E.JONES   CORRECTION FOR FIELD OF CONSTANT DATA
         14 |C   92-10-16  R.E.JONES   GET RID OF ARRAYS FP AND INT
         15 |C   93-08-06  CAVANAUGH   ADDED ROUTINES FI7501, FI7502, FI7503
         16 |C                         TO ALLOW SECOND ORDER PACKING IN PDS.
         17 |C   93-07-21 STACKPOLE    ASSORTED REPAIRS TO GET 2ND DIFF PACK IN
         18 |C   93-10-28 CAVANAUGH    COMMENTED OUT NONOPERATIONAL PRINTS AND
         19 |C                         WRITE STATEMENTS
         20 |C   93-12-15  CAVANAUGH   CORRECTED LOCATION OF START OF FIRST ORDER
         21 |C                         VALUES AND START OF SECOND ORDER VALUES TO
         22 |C                         REFLECT A BYTE LOCATION IN THE BDS INSTEAD
         23 |C                         OF AN OFFSET IN SUBROUTINE FI7501.
         24 |C   94-01-27  CAVANAUGH   ADDED IGDS AS INPUT ARGUMENT TO THIS ROUTINE
         25 |C                         AND ADDED PDS AND IGDS ARRAYS TO THE CALL TO
         26 |C                         W3FI82 TO PROVIDE INFORMATION NEEDED FOR
         27 |C                         BOUSTROPHEDONIC PROCESSING.
         28 |C   94-05-25  CAVANAUGH   SUBROUTINE FI7503 HAS BEEN ADDED TO PROVIDE
         29 |C                         FOR ROW BY ROW OR COLUMN BY COLUMN SECOND
         30 |C                         ORDER PACKING.  THIS FEATURE CAN BE ACTIVATED
         31 |C                         BY SETTING IBDSFL(7) TO ZERO.
         32 |C   94-07-08  CAVANAUGH   COMMENTED OUT PRINT STATEMENTS USED FOR DEBUG
         33 |C   94-11-22  FARLEY      ENLARGED WORK ARRAYS TO HANDLE .5DEGREE GRIDS
         34 |C   95-06-01  R.E.JONES   CORRECTION FOR NUMBER OF UNUSED BITS AT END
         35 |C                         OF SECTION 4, IN BDS BYTE 4, BITS 5-8.
         36 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
         37 |C
         38 |C USAGE:    CALL W3FI75 (IBITL,ITYPE,ITOSS,FLD,IFLD,IBMAP,IBDSFL,
         39 |C    &              NPTS,BDS11,IPFLD,PFLD,LEN,LENBDS,IBERR,PDS,IGDS)
         40 |C   INPUT ARGUMENT LIST:
         41 |C     IBITL     - 0, COMPUTER COMPUTES PACKING LENGTH FROM POWER
         42 |C                    OF 2 THAT BEST FITS THE DATA.
         43 |C                 8, 12, ETC. COMPUTER RESCALES DATA TO FIT INTO
         44 |C                    SET NUMBER OF BITS.
         45 |C     ITYPE     - 0 = IF INPUT DATA IS FLOATING POINT (FLD)
         46 |C                 1 = IF INPUT DATA IS INTEGER (IFLD)
         47 |C     ITOSS     - 0 = NO BIT MAP IS INCLUDED (DON'T TOSS DATA)
         48 |C                 1 = TOSS NULL DATA ACCORDING TO IBMAP
         49 |C     FLD       - REAL ARRAY OF DATA TO BE PACKED IF ITYPE=0
         50 |C     IFLD      - INTEGER ARRAY TO BE PACKED IF ITYPE=1
         51 |C     IBMAP     - BIT MAP SUPPLIED FROM USER
         52 |C     IBDSFL    - INTEGER ARRAY CONTAINING TABLE 11 FLAG INFO
         53 |C                 BDS OCTET 4:
         54 |C                 (1) 0 = GRID POINT DATA
         55 |C                     1 = SPHERICAL HARMONIC COEFFICIENTS
         56 |C                 (2) 0 = SIMPLE PACKING
         57 |C                     1 = SECOND ORDER PACKING
         58 |C                 (3) 0 = ORIGINAL DATA WERE FLOATING POINT VALUES
         59 |C                     1 = ORIGINAL DATA WERE INTEGER VALUES
         60 |C                 (4) 0 = NO ADDITIONAL FLAGS AT OCTET 14
         61 |C                     1 = OCTET 14 CONTAINS FLAG BITS 5-12
         62 |C                 (5) 0 = RESERVED - ALWAYS SET TO 0
         63 |C                 (6) 0 = SINGLE DATUM AT EACH GRID POINT
         64 |C                     1 = MATRIX OF VALUES AT EACH GRID POINT
         65 |C                 (7) 0 = NO SECONDARY BIT MAPS
         66 |C                     1 = SECONDARY BIT MAPS PRESENT
         67 |C                 (8) 0 = SECOND ORDER VALUES HAVE CONSTANT WIDTH
         68 |C                     1 = SECOND ORDER VALUES HAVE DIFFERENT WIDTHS
         69 |C     NPTS      - NUMBER OF GRIDPOINTS IN ARRAY TO BE PACKED
         70 |C     IGDS      - ARRAY OF GDS INFORMATION
         71 |C
         72 |C   OUTPUT ARGUMENT LIST:
         73 |C     BDS11     - FIRST 11 OCTETS OF BDS
         74 |C     PFLD      - PACKED GRIB FIELD
         75 |C     LEN       - LENGTH OF PFLD
         76 |C     LENBDS    - LENGTH OF BDS
         77 |C     IBERR     - 1, ERROR CONVERTING IEEE F.P. NUMBER TO IBM370 F.P.
         78 |C
         79 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
         80 |C
         81 |C ATTRIBUTES:
         82 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
         83 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
         84 |C
         85 |C$$$
         86 |C
         87 |      REAL            FLD(*)
         88 |C     REAL            FWORK(260000)
         89 |C
         90 |C     FWORK CAN USE DYNAMIC ALLOCATION OF MEMORY ON CRAY
         91 |C
         92 |      REAL            FWORK(NPTS)
         93 |      REAL            RMIN,REFNCE
         94 |C
         95 |      INTEGER         IPFLD(*)
         96 |      INTEGER         IBDSFL(*)
         97 |      INTEGER         IBMAP(*)
         98 |      INTEGER         IFLD(*),IGDS(*)
         99 |C     INTEGER         IWORK(260000)
        100 |C
        101 |C     IWORK CAN USE DYNAMIC ALLOCATION OF MEMORY ON CRAY
        102 |C
        103 |      INTEGER         IWORK(NPTS)
        104 |C
        105 |      LOGICAL         CONST
        106 |C
        107 |      CHARACTER * 1   BDS11(11),PDS(*)
        108 |      CHARACTER * 1   PFLD(*)
        109 |      CHARACTER * 1   CIEXP(8)
        110 |      CHARACTER * 1   CIMANT(8)
        111 |C
        112 |      EQUIVALENCE     (IEXP,CIEXP(1))
        113 |      EQUIVALENCE     (IMANT,CIMANT(1))
        114 |C
        115 |C            1.0   PACK THE FIELD.
        116 |C
        117 |C            1.1   TOSS DATA IF BITMAP BEING USED,
        118 |C                  MOVING 'DATA' TO WORK AREA...
        119 |C
        120 |
        121 |      CONST = .FALSE.
        122 |      IBERR = 0
        123 |      IW    = 0
        124 |C
        125 |      IF (ITOSS .EQ. 1) THEN
        126 |        IF (ITYPE .EQ. 0) THEN
        127 |          DO 110 IT=1,NPTS
        128 |            IF (IBMAP(IT) .EQ. 1) THEN
        129 |              IW = IW + 1
        130 |              FWORK(IW) = FLD(IT)
        131 |            ENDIF
        132 |  110     CONTINUE
        133 |          NPTS = IW
        134 |        ELSE IF (ITYPE .EQ. 1) THEN
        135 |          DO 111 IT=1,NPTS
        136 |            IF (IBMAP(IT) .EQ. 1) THEN
        137 |              IW = IW + 1
        138 |              IWORK(IW) = IFLD(IT)
        139 |            ENDIF
        140 |  111     CONTINUE
        141 |          NPTS = IW
        142 |        ENDIF
        143 |C
        144 |C             ELSE, JUST MOVE DATA TO WORK ARRAY
        145 |C
        146 |      ELSE IF (ITOSS .EQ. 0) THEN
        147 |        IF (ITYPE .EQ. 0) THEN
        148 |          DO 112 IT=1,NPTS
        149 |            FWORK(IT) = FLD(IT)
        150 |  112     CONTINUE
        151 |        ELSE IF (ITYPE .EQ. 1) THEN
        152 |          DO 113 IT=1,NPTS
        153 |            IWORK(IT) = IFLD(IT)
        154 |  113     CONTINUE
        155 |        ENDIF
        156 |      ENDIF
        157 |C
        158 |C            1.2   CONVERT DATA IF NEEDED PRIOR TO PACKING.
        159 |C                  (INTEGER TO F.P. OR F.P. TO INTEGER)
        160 |C     ITYPE = 0...FLOATING POINT DATA
        161 |C       IBITL = 0...PACK IN LEAST # BITS...CONVERT TO INTEGER
        162 |C     ITYPE = 1...INTEGER DATA
        163 |C       IBITL > 0...PACK IN FIXED # BITS...CONVERT TO FLOATING POINT
        164 |C
        165 |      IF (ITYPE .EQ. 0 .AND. IBITL .EQ. 0) THEN
        166 |        DO 120 IF=1,NPTS
        167 |          IWORK(IF) = NINT(FWORK(IF))
        168 |  120   CONTINUE
        169 |      ELSE IF (ITYPE .EQ. 1 .AND. IBITL .NE. 0) THEN
        170 |        DO 123 IF=1,NPTS
        171 |          FWORK(IF) = FLOAT(IWORK(IF))
        172 |  123   CONTINUE
        173 |      ENDIF
        174 |C
        175 |C            1.3   PACK THE DATA.
        176 |C
        177 |      IF (IBDSFL(2).NE.0) THEN
        178 |C                                    SECOND ORDER PACKING
        179 |C
        180 |C            PRINT*,'  DOING SECOND ORDER PACKING...'
        181 |          IF (IBITL.EQ.0) THEN
        182 |C
        183 |C             PRINT*,'    AND VARIABLE BIT PACKING'
        184 |C
        185 |C                           WORKING WITH INTEGER VALUES
        186 |C                           SINCE DOING VARIABLE BIT PACKING
        187 |C
        188 |              MAX  = IWORK(1)
        189 |              MIN  = IWORK(1)
        190 |              DO 300 I = 2, NPTS
        191 |                  IF (IWORK(I).LT.MIN) THEN
        192 |                      MIN  = IWORK(I)
        193 |                  ELSE IF (IWORK(I).GT.MAX) THEN
        194 |                      MAX  = IWORK(I)
        195 |                  END IF
        196 |  300         CONTINUE
        197 |C                           EXTRACT MINIMA
        198 |              DO 400 I = 1, NPTS
        199 |C                 IF (IWORK(I).LT.0) THEN
        200 |C                     PRINT *,'MINIMA 400',I,IWORK(I),NPTS
        201 |C                 END IF
        202 |                  IWORK(I)  = IWORK(I) - MIN
        203 |  400         CONTINUE
        204 |              REFNCE  = MIN
        205 |              IDIFF   = MAX - MIN
        206 |C             PRINT *,'REFERENCE VALUE',REFNCE
        207 |C
        208 |C             WRITE (6,FMT='(''  MINIMA REMOVED      = '',/,
        209 |C    &              10(3X,10I10,/))') (IWORK(I),I=1,6)
        210 |C             WRITE (6,FMT='(''  END OF ARRAY  = '',/,
        211 |C    &              10(3X,10I10,/))') (IWORK(I),I=NPTS-5,NPTS)
        212 |C
        213 |C                      FIND BIT WIDTH OF IDIFF
        214 |C
        215 |              CALL FI7505 (IDIFF,KWIDE)
        216 |C             PRINT*,'  BIT WIDTH FOR ORIGINAL DATA', KWIDE
        217 |              ISCAL2 = 0
        218 |C
        219 |C             MULTIPLICATIVE SCALE FACTOR SET TO 1
        220 |C             IN ANTICIPATION OF POSSIBLE USE IN GLAHN 2DN DIFF
        221 |C
        222 |              SCAL2 = 1.
        223 |C
        224 |          ELSE
        225 |C
        226 |C             PRINT*,'   AND FIXED BIT PACKING, IBITL = ', IBITL
        227 |C                               FIXED BIT PACKING
        228 |C                               - LENGTH OF FIELD IN IBITL
        229 |C                               - MUST BE REAL DATA
        230 |C                            FLOATING POINT INPUT
        231 |C
        232 |              RMAX  = FWORK(1)
        233 |              RMIN  = FWORK(1)
        234 |              DO 100 I = 2, NPTS
        235 |                  IF (FWORK(I).LT.RMIN) THEN
        236 |                      RMIN  = FWORK(I)
        237 |                  ELSE IF (FWORK(I).GT.RMAX) THEN
        238 |                      RMAX  = FWORK(I)
        239 |                  END IF
        240 |  100         CONTINUE
        241 |              REFNCE  = RMIN
        242 |C             PRINT *,'100 REFERENCE',REFNCE
        243 |C                             EXTRACT MINIMA
        244 |              DO 200 I = 1, NPTS
        245 |                  FWORK(I)  = FWORK(I) - RMIN
        246 |  200         CONTINUE
        247 |C             PRINT *,'REFERENCE VALUE',REFNCE
        248 |C             WRITE (6,FMT='(''  MINIMA REMOVED      = '',/,
        249 |C    &              10(3X,10F8.2,/))') (FWORK(I),I=1,6)
        250 |C             WRITE (6,FMT='(''  END OF ARRAY  = '',/,
        251 |C    &              10(3X,10F8.2,/))') (FWORK(I),I=NPTS-5,NPTS)
        252 |C                                FIND LARGEST DELTA
        253 |              IDELT  = NINT(RMAX - RMIN)
        254 |C                                DO BINARY SCALING
        255 |C                                   FIND OUT WHAT BINARY SCALE FACTOR
        256 |C                                       PERMITS CONTAINMENT OF
        257 |C                                       LARGEST DELTA
        258 |              CALL FI7505 (IDELT,IWIDE)
        259 |C
        260 |C                                   BINARY SCALING
        261 |C
        262 |              ISCAL2  = IWIDE - IBITL
        263 |C             PRINT *,'SCALING NEEDED TO FIT =',ISCAL2
        264 |C             PRINT*,'  RANGE OF  = ',IDELT
        265 |C
        266 |C                                EXPAND DATA WITH BINARY SCALING
        267 |C                                CONVERT TO INTEGER
        268 |              SCAL2  = 2.0**ISCAL2
        269 |              SCAL2  = 1./ SCAL2
        270 |              DO 600 I = 1, NPTS
        271 |                  IWORK(I)  = NINT(FWORK(I) * SCAL2)
        272 |  600         CONTINUE
        273 |              KWIDE = IBITL
        274 |          END IF
        275 |C
        276 |C  *****************************************************************
        277 |C
        278 |C           FOLLOWING IS FOR GLAHN SECOND DIFFERENCING
        279 |C           NOT STANDARD GRIB
        280 |C
        281 |C            TEST FOR SECOND DIFFERENCE PACKING
        282 |C            BASED OF SIZE OF PDS - SIZE IN FIRST 3 BYTES
        283 |C
        284 |          CALL GBYTE (PDS,IPDSIZ,0,24)
        285 |          IF (IPDSIZ.EQ.50) THEN
        286 |C             PRINT*,'  DO SECOND DIFFERENCE PACKING '
        287 |C
        288 |C                   GLAHN PACKING TO 2ND DIFFS
        289 |C
        290 |C             WRITE (6,FMT='(''  CALL TO W3FI82 WITH = '',/,
        291 |C    &                  10(3X,10I6,/))') (IWORK(I),I=1,NPTS)
        292 |C
        293 |               CALL W3FI82 (IWORK,FVAL1,FDIFF1,NPTS,PDS,IGDS)
        294 |C
        295 |C             PRINT *,'GLAHN',FVAL1,FDIFF1
        296 |C             WRITE (6,FMT='(''  OUT FROM W3FI82 WITH = '',/,
        297 |C    &                  10(3X,10I6,/))') (IWORK(I),I=1,NPTS)
        298 |C
        299 |C             MUST NOW RE-REMOVE THE MINIMUM VALUE
        300 |C             OF THE SECOND DIFFERENCES TO ASSURE
        301 |C             ALL POSITIVE NUMBERS FOR SECOND ORDER GRIB PACKING
        302 |C
        303 |C             ORIGINAL REFERENCE VALUE ADDED TO FIRST POINT
        304 |C             VALUE FROM THE 2ND DIFF PACKER TO BE ADDED
        305 |C             BACK IN WHEN THE 2ND DIFF VALUES ARE
        306 |C             RECONSTRUCTED BACK TO THE BASIC VALUES
        307 |C
        308 |C             ALSO, THE REFERENCE VALUE IS
        309 |C             POWER-OF-TWO SCALED TO MATCH
        310 |C             FVAL1.  ALL OF THIS SCALING
        311 |C             WILL BE REMOVED AFTER THE
        312 |C             GLAHN SECOND DIFFERENCING IS UNDONE.
        313 |C             THE SCALING FACTOR NEEDED TO DO THAT
        314 |C             IS SAVED IN THE PDS AS A SIGNED POSITIVE
        315 |C             TWO BYTE INTEGER
        316 |C
        317 |C             THE SCALING FOR THE 2ND DIF PACKED
        318 |C             VALUES IS PROPERLY SET TO ZERO
        319 |C
        320 |              FVAL1 = FVAL1 + REFNCE*SCAL2
        321 |C                                          FIRST TEST TO SEE IF
        322 |C                                          ON 32 OR 64 BIT COMPUTER
        323 |              CALL W3FI01(LW)
        324 |              IF (LW.EQ.4) THEN
        325 |                  CALL W3FI76 (FVAL1,IEXP,IMANT,32)
        326 |              ELSE
        327 |                  CALL W3FI76 (FVAL1,IEXP,IMANT,64)
        328 |              END IF
        329 |              CALL SBYTE (PDS,IEXP,320,8)
        330 |              CALL SBYTE (PDS,IMANT,328,24)
        331 |C
        332 |              IF (LW.EQ.4) THEN
        333 |                  CALL W3FI76 (FDIFF1,IEXP,IMANT,32)
        334 |              ELSE
        335 |                  CALL W3FI76 (FDIFF1,IEXP,IMANT,64)
        336 |              END IF
        337 |              CALL SBYTE (PDS,IEXP,352,8)
        338 |              CALL SBYTE (PDS,IMANT,360,24)
        339 |C
        340 |C             TURN ISCAL2 INTO SIGNED POSITIVE INTEGER
        341 |C             AND STORE IN TWO BYTES
        342 |C
        343 |              IF(ISCAL2.GE.0)  THEN
        344 |                CALL SBYTE (PDS,ISCAL2,384,16)
        345 |              ELSE
        346 |                CALL SBYTE (PDS,1,384,1)
        347 |                ISCAL2 = - ISCAL2
        348 |                CALL SBYTE( PDS,ISCAL2,385,15)
        349 |              ENDIF
        350 |C
        351 |              MAX  = IWORK(1)
        352 |              MIN  = IWORK(1)
        353 |              DO 700 I = 2, NPTS
        354 |                  IF (IWORK(I).LT.MIN) THEN
        355 |                      MIN  = IWORK(I)
        356 |                  ELSE IF (IWORK(I).GT.MAX) THEN
        357 |                      MAX  = IWORK(I)
        358 |                  END IF
        359 |  700         CONTINUE
        360 |C                           EXTRACT MINIMA
        361 |              DO 710 I = 1, NPTS
        362 |                  IWORK(I)  = IWORK(I) - MIN
        363 |  710         CONTINUE
        364 |              REFNCE  = MIN
        365 |C             PRINT *,'710 REFERENCE',REFNCE
        366 |              ISCAL2 = 0
        367 |C
        368 |C             AND RESET VALUE OF KWIDE - THE BIT WIDTH
        369 |C             FOR THE RANGE OF THE VALUES
        370 |C
        371 |              IDIFF = MAX - MIN
        372 |              CALL FI7505 (IDIFF,KWIDE)
        373 |C
        374 |C             PRINT*,'BIT WIDTH (KWIDE) OF 2ND DIFFS', KWIDE
        375 |C
        376 |C  **************************** END OF GLAHN PACKING  ************
        377 |          ELSE IF (IBDSFL(2).EQ.1.AND.IBDSFL(7).EQ.0) THEN
        378 |C                        HAVE SECOND ORDER PACKING WITH NO SECOND ORDER
        379 |C                        BIT MAP. ERGO ROW BY ROW - COL BY COL
        380 |              CALL FI7503 (IWORK,IPFLD,NPTS,IBDSFL,BDS11,
        381 |     *              LEN,LENBDS,PDS,REFNCE,ISCAL2,KWIDE,IGDS)
        382 |              RETURN
        383 |          END IF
        384 |C         WRITE (6,FMT='(''  CALL TO FI7501 WITH = '',/,
        385 |C    &                  10(3X,10I6,/))') (IWORK(I),I=1,NPTS)
        386 |C         WRITE (6,FMT='(''  END OF ARRAY = '',/,
        387 |C    &                  10(3X,10I6,/))') (IWORK(I),I=NPTS-5,NPTS)
        388 |C         PRINT*,' REFNCE,ISCAL2, KWIDE AT CALL TO FI7501',
        389 |C    &             REFNCE, ISCAL2,KWIDE
        390 |C
        391 |C                         SECOND ORDER PACKING
        392 |C
        393 |          CALL FI7501 (IWORK,IPFLD,NPTS,IBDSFL,BDS11,
        394 |     *             LEN,LENBDS,PDS,REFNCE,ISCAL2,KWIDE)
        395 |C
        396 |C              BDS COMPLETELY ASSEMBLED IN FI7501 FOR SECOND ORDER
        397 |C              PACKING.
        398 |C
        399 |      ELSE
        400 |C                                      SIMPLE PACKING
        401 |C
        402 |C                PRINT*,'  SIMPLE FIRST ORDER PACKING...'
        403 |          IF (IBITL.EQ.0) THEN
        404 |C                PRINT*,' WITH VARIABLE BIT LENGTH'
        405 |C
        406 |C                  WITH VARIABLE BIT LENGTH, ADJUSTED
        407 |C                  TO ACCOMMODATE LARGEST VALUE
        408 |C                  BINARY SCALING ALWAYS = 0
        409 |C
        410 |              CALL W3FI58(IWORK,NPTS,IWORK,PFLD,NBITS,LEN,KMIN)
        411 |              RMIN   = KMIN
        412 |              REFNCE  = RMIN
        413 |              ISCALE = 0
        414 |C             PRINT*,'  BIT LENGTH CAME OUT AT ...',NBITS
        415 |C
        416 |C           SET CONST .TRUE. IF ALL VALUES ARE THE SAME
        417 |C
        418 |              IF (LEN.EQ.0.AND.NBITS.EQ.0) CONST = .TRUE.
        419 |C
        420 |          ELSE
        421 |C           PRINT*,' FIXED BIT LENGTH, IBITL = ', IBITL
        422 |C
        423 |C             FIXED BIT LENGTH PACKING (VARIABLE PRECISION)
        424 |C             VALUES SCALED BY POWER OF 2 (ISCALE) TO
        425 |C             FIT LARGEST VALUE INTO GIVEN BIT LENGTH (IBITL)
        426 |C
        427 |              CALL W3FI59(FWORK,NPTS,IBITL,IWORK,PFLD,ISCALE,LEN,RMIN)
        428 |              REFNCE = RMIN
        429 |C             PRINT *,' SCALING NEEDED TO FIT IS ...', ISCALE
        430 |              NBITS = IBITL
        431 |C
        432 |C           SET CONST .TRUE. IF ALL VALUES ARE THE SAME
        433 |C
        434 |              IF (LEN.EQ.0) THEN
        435 |                  CONST = .TRUE.
        436 |                  NBITS = 0
        437 |              END IF
        438 |          END IF
        439 |C
        440 |C$        COMPUTE LENGTH OF BDS IN OCTETS
        441 |C
        442 |          INUM  = NPTS * NBITS + 88
        443 |C         PRINT *,'NUMBER OF BITS BEFORE FILL ADDED',INUM
        444 |C
        445 |C                  NUMBER OF FILL BITS
        446 |          NFILL  = 0
        447 |          NLEFT  = MOD(INUM,16)
        448 |          IF (NLEFT.NE.0) THEN
        449 |              INUM  = INUM + 16 - NLEFT
        450 |              NFILL = 16 - NLEFT
        451 |          END IF
        452 |C         PRINT *,'NUMBER OF BITS AFTER FILL ADDED',INUM
        453 |C                  LENGTH OF BDS IN BYTES
        454 |          LENBDS = INUM / 8
        455 |C
        456 |C                2.0   FORM THE BINARY DATA SECTION (BDS).
        457 |C
        458 |C                 CONCANTENATE ALL FIELDS FOR BDS
        459 |C
        460 |C                               BYTES 1-3
        461 |          CALL SBYTE (BDS11,LENBDS,0,24)
        462 |C
        463 |C                               BYTE  4
        464 |C                                       FLAGS
        465 |          CALL SBYTE (BDS11,IBDSFL(1),24,1)
        466 |          CALL SBYTE (BDS11,IBDSFL(2),25,1)
        467 |          CALL SBYTE (BDS11,IBDSFL(3),26,1)
        468 |          CALL SBYTE (BDS11,IBDSFL(4),27,1)
        469 |C                                        NR OF FILL BITS
        470 |          CALL SBYTE (BDS11,NFILL,28,4)
        471 |C
        472 |C$      FILL OCTETS 5-6 WITH THE SCALE FACTOR.
        473 |C
        474 |C                               BYTE  5-6
        475 |          IF (ISCALE.LT.0) THEN
        476 |              CALL SBYTE (BDS11,1,32,1)
        477 |              ISCALE  = - ISCALE
        478 |              CALL SBYTE (BDS11,ISCALE,33,15)
        479 |          ELSE
        480 |              CALL SBYTE (BDS11,ISCALE,32,16)
        481 |          END IF
        482 |C
        483 |C$  FILL OCTET 7-10 WITH THE REFERENCE VALUE
        484 |C   CONVERT THE FLOATING POINT OF YOUR MACHINE TO IBM370 32 BIT
        485 |C   FLOATING POINT NUMBER
        486 |C
        487 |C                               BYTE  7-10
        488 |C                                        REFERENCE VALUE
        489 |C                                          FIRST TEST TO SEE IF
        490 |C                                          ON 32 OR 64 BIT COMPUTER
        491 |          CALL W3FI01(LW)
        492 |          IF (LW.EQ.4) THEN
        493 |              CALL W3FI76 (REFNCE,IEXP,IMANT,32)
        494 |          ELSE
        495 |              CALL W3FI76 (REFNCE,IEXP,IMANT,64)
        496 |          END IF
        497 |          CALL SBYTE (BDS11,IEXP,48,8)
        498 |          CALL SBYTE (BDS11,IMANT,56,24)
        499 |C
        500 |C
        501 |C$                        FILL OCTET 11 WITH THE NUMBER OF BITS.
        502 |C
        503 |C                               BYTE  11
        504 |          CALL SBYTE (BDS11,NBITS,80,8)
        505 |      END IF
        506 |C
        507 |      RETURN
        508 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
bds11                            Reference argument, Character(1) (1:11), Offset: 0, Alignment: byte
                                 0-107.23$  0-2.14  0-380.52  0-393.48  0-461.23  0-465.23  0-466.23  0-467.23  0-468.23  0-470.23
                                 0-476.27  0-478.27  0-480.27  0-497.23  0-498.23  0-504.23
 
ciexp                            Automatic, Character(1) (1:8), Offset: 0, Alignment: quadruple word
                                 0-109.23$  0-112.29
 
cimant                           Automatic, Character(1) (1:8), Offset: 0, Alignment: quadruple word
                                 0-110.23$  0-113.30
 
const                            Automatic, Logical(4), Offset: 0, Alignment: full word
                                 0-105.23$  0-121.7@  0-418.44@  0-435.19@
 
fdiff1                           Automatic, Real(4), Offset: 0, Alignment: full word
                                 0-293.41  0-333.32  0-335.32
 
fi7501                           External Subroutine
                                 0-393.16
 
fi7503                           External Subroutine
                                 0-380.20
 
fi7505                           External Subroutine
                                 0-215.20  0-258.20  0-372.20
 
fld                              Reference argument, Real(4) (1:*), Offset: 0, Alignment: full word
                                 0-87.23$  0-1.44  0-130.27  0-149.25
 
float                            Pure Intrinsic
                                 0-171.23
 
fval1                            Automatic, Real(4), Offset: 0, Alignment: full word
                                 0-293.35  0-320.15@  0-320.23  0-325.32  0-327.32
 
fwork                            Controlled Automatic, Real(4) (1:?), Offset: 0, Alignment: full word
                                 0-92.23$  0-130.15@  0-149.13@  0-167.28  0-171.11@  0-232.23  0-233.23  0-235.23  0-236.31
                                 0-237.28  0-238.31  0-245.19@  0-245.31  0-271.36  0-427.27
 
gbyte                            External Subroutine
                                 0-284.16
 
i                                Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-190.22@  0-191.29  0-192.36  0-193.34  0-194.36  0-198.22@  0-202.25  0-202.37  0-234.22@
                                 0-235.29  0-236.37  0-237.34  0-238.37  0-244.22@  0-245.25  0-245.37  0-270.22@  0-271.25
                                 0-271.42  0-353.22@  0-354.29  0-355.36  0-356.34  0-357.36  0-361.22@  0-362.25  0-362.37
 
ibdsfl                           Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-96.23$  0-1.59  0-177.11  0-377.20  0-377.39  0-380.45  0-393.41  0-465.29  0-466.29  0-467.29
                                 0-468.29
 
iberr                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-2.42  0-122.7@
 
ibitl                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1.26  0-165.30  0-169.35  0-181.15  0-262.33  0-273.23  0-403.15  0-427.38  0-430.23
 
ibmap                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-97.23$  0-1.53  0-128.17  0-136.17
 
idelt                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-253.15@  0-258.28
 
idiff                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-205.15@  0-215.28  0-371.15@  0-372.28
 
iexp                             Automatic, Integer(4), Offset: 0, Alignment: quadruple word
                                 0-112.24  0-325.38  0-327.38  0-329.31  0-333.39  0-335.39  0-337.31  0-493.35  0-495.35  0-497.29
 
if                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-166.16@  0-167.17  0-167.34  0-170.16@  0-171.17  0-171.35
 
ifld                             Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-98.23$  0-1.48  0-138.27  0-153.25
 
igds                             Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-98.31$  0-2.52  0-293.57  0-381.56
 
imant                            Automatic, Integer(4), Offset: 0, Alignment: quadruple word
                                 0-113.24  0-325.43  0-327.43  0-330.31  0-333.44  0-335.44  0-338.31  0-493.40  0-495.40  0-498.29
 
inum                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-442.11@  0-447.24  0-449.15@  0-449.23  0-454.20
 
ipdsiz                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-284.27  0-285.15
 
ipfld                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-95.23$  0-2.20  0-380.34  0-393.30
 
iscal2                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-217.15@  0-262.15@  0-268.29  0-343.18  0-344.33  0-347.17@  0-347.28  0-348.33  0-366.15@
                                 0-381.43  0-394.42
 
iscale                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-413.15@  0-427.55  0-475.15  0-477.15@  0-477.27  0-478.33  0-480.33
 
it                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-127.18@  0-128.23  0-130.31  0-135.18@  0-136.23  0-138.32  0-148.18@  0-149.19  0-149.29
                                 0-152.18@  0-153.19  0-153.30
 
itoss                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1.38  0-125.11  0-146.16
 
itype                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1.32  0-126.13  0-134.18  0-147.13  0-151.18  0-165.11  0-169.16
 
iw                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-123.7@  0-129.15@  0-129.20  0-130.21  0-133.18  0-137.15@  0-137.20  0-138.21  0-141.18
 
iwide                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-258.34  0-262.25
 
iwork                            Controlled Automatic, Integer(4) (1:?), Offset: 0, Alignment: full word
                                 0-103.23$  0-138.15@  0-153.13@  0-167.11@  0-171.29  0-188.22  0-189.22  0-191.23  0-192.30
                                 0-193.28  0-194.30  0-202.19@  0-202.31  0-271.19@  0-293.29  0-351.22  0-352.22  0-354.23
                                 0-355.30  0-356.28  0-357.30  0-362.19@  0-362.31  0-380.28  0-393.24  0-410.27  0-410.38  0-427.44
 
kmin                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-410.59  0-411.24
 
kwide                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-215.34  0-273.15@  0-372.34  0-381.50  0-394.49
 
len                              Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-2.31  0-381.21  0-394.20  0-410.55  0-418.19  0-427.62  0-434.19
 
lenbds                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-2.35  0-381.25  0-394.24  0-454.11@  0-461.29
 
lw                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-323.27  0-324.19  0-332.19  0-491.23  0-492.15
 
max                              Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-188.15@  0-193.40  0-194.23@  0-205.25  0-351.15@  0-356.40  0-357.23@  0-371.23
 
min                              Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-189.15@  0-191.35  0-192.23@  0-202.42  0-204.25  0-205.31  0-352.15@  0-354.35  0-355.23@
                                 0-362.42  0-364.25  0-371.29
 
mod                              Pure Intrinsic
                                 0-447.20
 
nbits                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-410.49  0-418.32  0-430.15@  0-436.19@  0-442.26  0-504.29
 
nfill                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-446.11@  0-450.15@  0-470.29
 
nint                             Pure Intrinsic
                                 0-167.23  0-253.24  0-271.31
 
nleft                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-447.11@  0-448.15  0-449.35  0-450.28
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-2.9  0-92.29  0-92.29  0-103.29  0-103.29  0-127.23  0-133.11@  0-135.23  0-141.11@  0-148.23
                                 0-152.23  0-166.21  0-170.21  0-190.29  0-198.29  0-234.29  0-244.29  0-270.29  0-293.48  0-353.29
                                 0-361.29  0-380.40  0-393.36  0-410.33  0-427.33  0-442.19
 
pds                              Reference argument, Character(1) (1:*), Offset: 0, Alignment: byte
                                 0-107.33$  0-2.48  0-284.23  0-293.53  0-329.27  0-330.27  0-337.27  0-338.27  0-344.29  0-346.29
                                 0-348.29  0-381.32  0-394.31
 
pfld                             Reference argument, Character(1) (1:*), Offset: 0, Alignment: byte
                                 0-108.23$  0-2.26  0-410.44  0-427.50
 
refnce                           Automatic, Real(4), Offset: 0, Alignment: full word
                                 0-93.28$  0-204.15@  0-241.15@  0-320.31  0-364.15@  0-381.36  0-394.35  0-412.15@  0-428.15@
                                 0-493.28  0-495.28
 
rmax                             Automatic, Real(4), Offset: 0, Alignment: full word
                                 0-232.15@  0-237.40  0-238.23@  0-253.29
 
rmin                             Automatic, Real(4), Offset: 0, Alignment: full word
                                 0-93.23$  0-233.15@  0-235.35  0-236.23@  0-241.25  0-245.42  0-253.36  0-411.15@  0-412.25
                                 0-427.66  0-428.24
 
sbyte                            External Subroutine
                                 0-329.20  0-330.20  0-337.20  0-338.20  0-344.22  0-346.22  0-348.22  0-461.16  0-465.16  0-466.16
                                 0-467.16  0-468.16  0-470.16  0-476.20  0-478.20  0-480.20  0-497.16  0-498.16  0-504.16
 
scal2                            Automatic, Real(4), Offset: 0, Alignment: full word
                                 0-222.15@  0-268.15@  0-269.15@  0-269.28  0-271.47  0-320.38
 
w3fi01                           External Subroutine
                                 0-323.20  0-491.16
 
w3fi58                           External Subroutine
                                 0-410.20
 
w3fi59                           External Subroutine
                                 0-427.20
 
w3fi75                           Subroutine
                                 0-1.18$
 
w3fi76                           External Subroutine
                                 0-325.24  0-327.24  0-333.24  0-335.24  0-493.20  0-495.20
 
w3fi82                           External Subroutine
                                 0-293.21
 
** w3fi75   === End of Compilation 1 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
        509 |      SUBROUTINE FI7501 (IWORK,IPFLD,NPTS,IBDSFL,BDS11,
        510 |     *           LEN,LENBDS,PDS,REFNCE,ISCAL2,KWIDE)
        511 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
        512 |C                .      .    .                                       .
        513 |C SUBPROGRAM:    FI7501      BDS SECOND ORDER PACKING
        514 |C   PRGMMR: CAVANAUGH        ORG: W/NMC42    DATE: 93-08-06
        515 |C
        516 |C ABSTRACT: PERFORM SECONDARY PACKING ON GRID POINT DATA,
        517 |C   GENERATING ALL BDS INFORMATION.
        518 |C
        519 |C PROGRAM HISTORY LOG:
        520 |C   93-08-06  CAVANAUGH
        521 |C   93-12-15  CAVANAUGH   CORRECTED LOCATION OF START OF FIRST ORDER
        522 |C                         VALUES AND START OF SECOND ORDER VALUES TO
        523 |C                         REFLECT A BYTE LOCATION IN THE BDS INSTEAD
        524 |C                         OF AN OFFSET.
        525 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
        526 |C
        527 |C USAGE:    CALL FI7501 (IWORK,IPFLD,NPTS,IBDSFL,BDS11,
        528 |C    *           LEN,LENBDS,PDS,REFNCE,ISCAL2,KWIDE)
        529 |C   INPUT ARGUMENT LIST:
        530 |C     IWORK    - INTEGER SOURCE ARRAY
        531 |C     NPTS     - NUMBER OF POINTS IN IWORK
        532 |C     IBDSFL   - FLAGS
        533 |C
        534 |C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
        535 |C     IPFLD    - CONTAINS BDS FROM BYTE 12 ON
        536 |C     BDS11    - CONTAINS FIRST 11 BYTES FOR BDS
        537 |C     LEN      - NUMBER OF BYTES FROM 12 ON
        538 |C     LENBDS   - TOTAL LENGTH OF BDS
        539 |C
        540 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
        541 |C
        542 |C ATTRIBUTES:
        543 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
        544 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
        545 |C
        546 |C$$$
        547 |      CHARACTER*1     BDS11(*),PDS(*)
        548 |C
        549 |      REAL            REFNCE
        550 |C
        551 |      INTEGER         ISCAL2,KWIDE
        552 |      INTEGER         LENBDS
        553 |      INTEGER         IPFLD(*)
        554 |      INTEGER         LEN,KBDS(22)
        555 |      INTEGER         IWORK(*)
        556 |C                        OCTET NUMBER IN SECTION, FIRST ORDER PACKING
        557 |C     INTEGER         KBDS(12)
        558 |C                        FLAGS
        559 |      INTEGER         IBDSFL(*)
        560 |C                        EXTENDED FLAGS
        561 |C     INTEGER         KBDS(14)
        562 |C                        OCTET NUMBER FOR SECOND ORDER PACKING
        563 |C     INTEGER         KBDS(15)
        564 |C                        NUMBER OF FIRST ORDER VALUES
        565 |C     INTEGER         KBDS(17)
        566 |C                        NUMBER OF SECOND ORDER PACKED VALUES
        567 |C     INTEGER         KBDS(19)
        568 |C                        WIDTH OF SECOND ORDER PACKING
        569 |      INTEGER         ISOWID(50000)
        570 |C                        SECONDARY BIT MAP
        571 |      INTEGER         ISOBMP(8200)
        572 |C                        FIRST ORDER PACKED VALUES
        573 |      INTEGER         IFOVAL(50000)
        574 |C                        SECOND ORDER PACKED VALUES
        575 |      INTEGER         ISOVAL(100000)
        576 |C
        577 |C     INTEGER         KBDS(11)
        578 |C                        BIT WIDTH TABLE
        579 |      INTEGER         IBITS(31)
        580 |C
        581 |      DATA            IBITS/1,3,7,15,31,63,127,255,511,1023,
        582 |     *                      2047,4095,8191,16383,32767,65535,131072,
        583 |     *                      262143,524287,1048575,2097151,4194303,
        584 |     *                      8388607,16777215,33554431,67108863,
        585 |     *                      134217727,268435455,536870911,
        586 |     *                      1073741823,2147483647/
        587 |C  ----------------------------------
        588 |C                       INITIALIZE ARRAYS
        589 |      DO 100 I = 1, 50000
        590 |          ISOWID(I)  = 0
        591 |          IFOVAL(I)  = 0
        592 |  100 CONTINUE
        593 |C
        594 |      DO 101 I = 1, 8200
        595 |          ISOBMP(I)  = 0
        596 |  101 CONTINUE
        597 |      DO 102 I = 1, 100000
        598 |          ISOVAL(I)  = 0
        599 |  102 CONTINUE
        600 |C                      INITIALIZE POINTERS
        601 |C                            SECONDARY BIT WIDTH POINTER
        602 |      IWDPTR  = 0
        603 |C                            SECONDARY BIT MAP POINTER
        604 |      IBMP2P  = 0
        605 |C                            FIRST ORDER VALUE POINTER
        606 |      IFOPTR  = 0
        607 |C                            BYTE POINTER TO START OF 1ST ORDER VALUES
        608 |      KBDS(12)  = 0
        609 |C                            BYTE POINTER TO START OF 2ND ORDER VALUES
        610 |      KBDS(15)  = 0
        611 |C                            TO CONTAIN NUMBER OF FIRST ORDER VALUES
        612 |      KBDS(17)  = 0
        613 |C                            TO CONTAIN NUMBER OF SECOND ORDER VALUES
        614 |      KBDS(19)  = 0
        615 |C                            SECOND ORDER PACKED VALUE POINTER
        616 |      ISOPTR  = 0
        617 |C  =======================================================
        618 |C
        619 |C                         DATA IS IN IWORK
        620 |C
        621 |      KBDS(11)  = KWIDE
        622 |C
        623 |C       DATA PACKING
        624 |C
        625 |      ITER    = 0
        626 |      INEXT   = 1
        627 |      ISTART  = 1
        628 |C  -----------------------------------------------------------
        629 |      KOUNT = 0
        630 |C     DO 1 I = 1, NPTS, 10
        631 |C         PRINT *,I,(IWORK(K),K=I, I+9)
        632 |C   1 CONTINUE
        633 | 2000 CONTINUE
        634 |      ITER  = ITER + 1
        635 |C     PRINT *,'NEXT ITERATION STARTS AT',ISTART
        636 |       IF (ISTART.GT.NPTS) THEN
        637 |           GO TO 4000
        638 |       ELSE IF (ISTART.EQ.NPTS) THEN
        639 |           KPTS    = 1
        640 |           MXDIFF  = 0
        641 |           GO TO 2200
        642 |       END IF
        643 |C
        644 |C                     LOOK FOR REPITITIONS OF A SINGLE VALUE
        645 |       CALL FI7502 (IWORK,ISTART,NPTS,ISAME)
        646 |       IF (ISAME.GE.15) THEN
        647 |           KOUNT = KOUNT + 1
        648 |C          PRINT *,'FI7501 - FOUND IDENTICAL SET OF ',ISAME
        649 |           MXDIFF  = 0
        650 |           KPTS    = ISAME
        651 |       ELSE
        652 |C
        653 |C                     LOOK FOR SETS OF VALUES IN TREND SELECTED RANGE
        654 |           CALL FI7513 (IWORK,ISTART,NPTS,NMAX,NMIN,INRNGE)
        655 |C          PRINT *,'ISTART  ',ISTART,' INRNGE',INRNGE,NMAX,NMIN
        656 |           IEND  = ISTART + INRNGE - 1
        657 |C          DO 2199 NM = ISTART, IEND, 10
        658 |C              PRINT *,'  ',(IWORK(NM+JK),JK=0,9)
        659 |C2199      CONTINUE
        660 |           MXDIFF  = NMAX - NMIN
        661 |           KPTS    = INRNGE
        662 |       END IF
        663 | 2200 CONTINUE
        664 |C     PRINT *,'                 RANGE ',MXDIFF,' MAX',NMAX,' MIN',NMIN
        665 |C                 INCREMENT NUMBER OF FIRST ORDER VALUES
        666 |      KBDS(17)  = KBDS(17) + 1
        667 |C                 ENTER FIRST ORDER VALUE
        668 |      IF (MXDIFF.GT.0) THEN
        669 |          DO 2220 LK = 0, KPTS-1
        670 |              IWORK(ISTART+LK)  = IWORK(ISTART+LK) - NMIN
        671 | 2220     CONTINUE
        672 |          CALL SBYTE (IFOVAL,NMIN,IFOPTR,KBDS(11))
        673 |      ELSE
        674 |          CALL SBYTE (IFOVAL,IWORK(ISTART),IFOPTR,KBDS(11))
        675 |      END IF
        676 |      IFOPTR  = IFOPTR + KBDS(11)
        677 |C                  PROCESS SECOND ORDER BIT WIDTH
        678 |      IF (MXDIFF.GT.0) THEN
        679 |          DO 2330 KWIDE = 1, 31
        680 |              IF (MXDIFF.LE.IBITS(KWIDE)) THEN
        681 |                  GO TO 2331
        682 |              END IF
        683 | 2330     CONTINUE
        684 | 2331     CONTINUE
        685 |      ELSE
        686 |          KWIDE  = 0
        687 |      END IF
        688 |      CALL SBYTE (ISOWID,KWIDE,IWDPTR,8)
        689 |      IWDPTR  = IWDPTR + 8
        690 |C         PRINT *,KWIDE,' IFOVAL=',NMIN,IWORK(ISTART),KPTS
        691 |C               IF KWIDE NE 0, SAVE SECOND ORDER VALUE
        692 |      IF (KWIDE.GT.0) THEN
        693 |          CALL SBYTES (ISOVAL,IWORK(ISTART),ISOPTR,KWIDE,0,KPTS)
        694 |          ISOPTR  = ISOPTR + KPTS * KWIDE
        695 |          KBDS(19)  = KBDS(19) + KPTS
        696 |C         PRINT *,'            SECOND ORDER VALUES'
        697 |C         PRINT *,(IWORK(ISTART+I),I=0,KPTS-1)
        698 |      END IF
        699 |C                 ADD TO SECOND ORDER BITMAP
        700 |      CALL SBYTE (ISOBMP,1,IBMP2P,1)
        701 |      IBMP2P  = IBMP2P + KPTS
        702 |      ISTART  = ISTART + KPTS
        703 |      GO TO 2000
        704 |C  --------------------------------------------------------------
        705 | 4000 CONTINUE
        706 |C     PRINT *,'THERE WERE ',ITER,' SECOND ORDER GROUPS'
        707 |C     PRINT *,'THERE WERE ',KOUNT,' STRINGS OF CONSTANTS'
        708 |C                 CONCANTENATE ALL FIELDS FOR BDS
        709 |C
        710 |C                   REMAINDER GOES INTO IPFLD
        711 |      IPTR  = 0
        712 |C                               BYTES 12-13
        713 |C                                          VALUE FOR N1
        714 |C                                          LEAVE SPACE FOR THIS
        715 |      IPTR   = IPTR + 16
        716 |C                               BYTE 14
        717 |C                                          EXTENDED FLAGS
        718 |      CALL SBYTE (IPFLD,IBDSFL(5),IPTR,1)
        719 |      IPTR  = IPTR + 1
        720 |      CALL SBYTE (IPFLD,IBDSFL(6),IPTR,1)
        721 |      IPTR  = IPTR + 1
        722 |      CALL SBYTE (IPFLD,IBDSFL(7),IPTR,1)
        723 |      IPTR  = IPTR + 1
        724 |      CALL SBYTE (IPFLD,IBDSFL(8),IPTR,1)
        725 |      IPTR  = IPTR + 1
        726 |      CALL SBYTE (IPFLD,IBDSFL(9),IPTR,1)
        727 |      IPTR  = IPTR + 1
        728 |      CALL SBYTE (IPFLD,IBDSFL(10),IPTR,1)
        729 |      IPTR  = IPTR + 1
        730 |      CALL SBYTE (IPFLD,IBDSFL(11),IPTR,1)
        731 |      IPTR  = IPTR + 1
        732 |      CALL SBYTE (IPFLD,IBDSFL(12),IPTR,1)
        733 |      IPTR  = IPTR + 1
        734 |C                               BYTES 15-16
        735 |C                 SKIP OVER VALUE  FOR N2
        736 |      IPTR  = IPTR + 16
        737 |C                               BYTES 17-18
        738 |C                                     P1
        739 |      CALL SBYTE (IPFLD,KBDS(17),IPTR,16)
        740 |      IPTR  = IPTR + 16
        741 |C                               BYTES 19-20
        742 |C                                   P2
        743 |      CALL SBYTE (IPFLD,KBDS(19),IPTR,16)
        744 |      IPTR  = IPTR + 16
        745 |C                               BYTE 21 - RESERVED LOCATION
        746 |      CALL SBYTE (IPFLD,0,IPTR,8)
        747 |      IPTR  = IPTR + 8
        748 |C                               BYTES 22 - ?
        749 |C                                      WIDTHS OF SECOND ORDER PACKING
        750 |      IX    = (IWDPTR + 32) / 32
        751 |      CALL SBYTES (IPFLD,ISOWID,IPTR,32,0,IX)
        752 |      IPTR  = IPTR + IWDPTR
        753 |C                                      SECONDARY BIT MAP
        754 |      IJ    = (IBMP2P + 32) / 32
        755 |      CALL SBYTES (IPFLD,ISOBMP,IPTR,32,0,IJ)
        756 |      IPTR  = IPTR + IBMP2P
        757 |      IF (MOD(IPTR,8).NE.0) THEN
        758 |          IPTR  = IPTR + 8 - MOD(IPTR,8)
        759 |      END IF
        760 |C                                         DETERMINE LOCATION FOR START
        761 |C                                         OF FIRST ORDER PACKED VALUES
        762 |      KBDS(12)  = IPTR / 8 + 12
        763 |C                                        STORE LOCATION
        764 |      CALL SBYTE (IPFLD,KBDS(12),0,16)
        765 |C                                     MOVE IN FIRST ORDER PACKED VALUES
        766 |      IPASS   = (IFOPTR + 32) / 32
        767 |      CALL SBYTES (IPFLD,IFOVAL,IPTR,32,0,IPASS)
        768 |      IPTR  = IPTR + IFOPTR
        769 |      IF (MOD(IPTR,8).NE.0) THEN
        770 |          IPTR  = IPTR + 8 - MOD(IPTR,8)
        771 |      END IF
        772 |C     PRINT *,'IFOPTR =',IFOPTR,' ISOPTR =',ISOPTR
        773 |C                DETERMINE LOCATION FOR START
        774 |C                     OF SECOND ORDER VALUES
        775 |      KBDS(15)  = IPTR / 8 + 12
        776 |C                                   SAVE LOCATION OF SECOND ORDER VALUES
        777 |      CALL SBYTE (IPFLD,KBDS(15),24,16)
        778 |C                  MOVE IN SECOND ORDER PACKED VALUES
        779 |      IX    = (ISOPTR + 32) / 32
        780 |      CALL SBYTES (IPFLD,ISOVAL,IPTR,32,0,IX)
        781 |      IPTR  = IPTR + ISOPTR
        782 |      NLEFT  = MOD(IPTR+88,16)
        783 |      IF (NLEFT.NE.0) THEN
        784 |          NLEFT  = 16 - NLEFT
        785 |          IPTR   = IPTR + NLEFT
        786 |      END IF
        787 |C                                COMPUTE LENGTH OF DATA PORTION
        788 |      LEN     = IPTR / 8
        789 |C                                    COMPUTE LENGTH OF BDS
        790 |      LENBDS  = LEN + 11
        791 |C  -----------------------------------
        792 |C                               BYTES 1-3
        793 |C                                   THIS FUNCTION COMPLETED BELOW
        794 |C                                   WHEN LENGTH OF BDS IS KNOWN
        795 |      CALL SBYTE (BDS11,LENBDS,0,24)
        796 |C                               BYTE  4
        797 |      CALL SBYTE (BDS11,IBDSFL(1),24,1)
        798 |      CALL SBYTE (BDS11,IBDSFL(2),25,1)
        799 |      CALL SBYTE (BDS11,IBDSFL(3),26,1)
        800 |      CALL SBYTE (BDS11,IBDSFL(4),27,1)
        801 |C                              ENTER NUMBER OF FILL BITS
        802 |      CALL SBYTE (BDS11,NLEFT,28,4)
        803 |C                               BYTE  5-6
        804 |      IF (ISCAL2.LT.0) THEN
        805 |          CALL SBYTE (BDS11,1,32,1)
        806 |          ISCAL2 = - ISCAL2
        807 |      ELSE
        808 |          CALL SBYTE (BDS11,0,32,1)
        809 |      END IF
        810 |      CALL SBYTE (BDS11,ISCAL2,33,15)
        811 |C
        812 |C$  FILL OCTET 7-10 WITH THE REFERENCE VALUE
        813 |C   CONVERT THE FLOATING POINT OF YOUR MACHINE TO IBM370 32 BIT
        814 |C   FLOATING POINT NUMBER
        815 |C                                        REFERENCE VALUE
        816 |C                                          FIRST TEST TO SEE IF
        817 |C                                          ON 32 OR 64 BIT COMPUTER
        818 |          CALL W3FI01(LW)
        819 |          IF (LW.EQ.4) THEN
        820 |              CALL W3FI76 (REFNCE,IEXP,IMANT,32)
        821 |          ELSE
        822 |              CALL W3FI76 (REFNCE,IEXP,IMANT,64)
        823 |          END IF
        824 |          CALL SBYTE (BDS11,IEXP,48,8)
        825 |          CALL SBYTE (BDS11,IMANT,56,24)
        826 |C
        827 |C                               BYTE  11
        828 |C
        829 |      CALL SBYTE (BDS11,KBDS(11),80,8)
        830 |C
        831 |      RETURN
        832 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
bds11                            Reference argument, Character(1) (1:*), Offset: 0, Alignment: byte
                                 0-547.23$  0-509.50  0-795.19  0-797.19  0-798.19  0-799.19  0-800.19  0-802.19  0-805.23  0-808.23
                                 0-810.19  0-824.23  0-825.23  0-829.19
 
fi7501                           Subroutine
                                 0-509.18$
 
fi7502                           External Subroutine
                                 0-645.13
 
fi7513                           External Subroutine
                                 0-654.17
 
i                                Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-589.14@  0-590.18  0-591.18  0-594.14@  0-595.18  0-597.14@  0-598.18
 
ibdsfl                           Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-559.23$  0-509.43  0-718.25  0-720.25  0-722.25  0-724.25  0-726.25  0-728.25  0-730.25  0-732.25
                                 0-797.25  0-798.25  0-799.25  0-800.25
 
ibits                            Static, Integer(4) (1:31), Offset: 0, Alignment: full word
                                 0-579.23$  0-581.23*  0-680.29
 
ibmp2p                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-604.7@  0-700.28  0-701.7@  0-701.17  0-754.16  0-756.22
 
iend                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-656.12@
 
iexp                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-820.35  0-822.35  0-824.29
 
ifoptr                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-606.7@  0-672.35  0-674.44  0-676.7@  0-676.17  0-766.18  0-768.22
 
ifoval                           Automatic, Integer(4) (1:50000), Offset: 0, Alignment: full word
                                 0-573.23$  0-591.11@  0-672.23  0-674.23  0-767.26
 
ij                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-754.7@  0-755.43
 
imant                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-820.40  0-822.40  0-825.29
 
inext                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-626.7@
 
inrnge                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-654.53  0-656.29  0-661.22
 
ipass                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-766.7@  0-767.43
 
ipfld                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-553.23$  0-509.32  0-718.19  0-720.19  0-722.19  0-724.19  0-726.19  0-728.19  0-730.19  0-732.19
                                 0-739.19  0-743.19  0-746.19  0-751.20  0-755.20  0-764.19  0-767.20  0-777.19  0-780.20
 
iptr                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-711.7@  0-715.7@  0-715.16  0-718.35  0-719.7@  0-719.15  0-720.35  0-721.7@  0-721.15  0-722.35
                                 0-723.7@  0-723.15  0-724.35  0-725.7@  0-725.15  0-726.35  0-727.7@  0-727.15  0-728.36  0-729.7@
                                 0-729.15  0-730.36  0-731.7@  0-731.15  0-732.36  0-733.7@  0-733.15  0-736.7@  0-736.15  0-739.34
                                 0-740.7@  0-740.15  0-743.34  0-744.7@  0-744.15  0-746.27  0-747.7@  0-747.15  0-751.33  0-752.7@
                                 0-752.15  0-755.33  0-756.7@  0-756.15  0-757.15  0-758.11@  0-758.19  0-758.34  0-762.19  0-767.33
                                 0-768.7@  0-768.15  0-769.15  0-770.11@  0-770.19  0-770.34  0-775.19  0-780.33  0-781.7@  0-781.15
                                 0-782.20  0-785.11@  0-785.20  0-788.17
 
isame                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-645.39  0-646.12  0-650.22
 
iscal2                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-551.23$  0-510.40  0-804.11  0-806.11@  0-806.22  0-810.25
 
isobmp                           Automatic, Integer(4) (1:8200), Offset: 0, Alignment: full word
                                 0-571.23$  0-595.11@  0-700.19  0-755.26
 
isoptr                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-616.7@  0-693.45  0-694.11@  0-694.21  0-779.16  0-781.22
 
isoval                           Automatic, Integer(4) (1:100000), Offset: 0, Alignment: full word
                                 0-575.23$  0-598.11@  0-693.24  0-780.26
 
isowid                           Automatic, Integer(4) (1:50000), Offset: 0, Alignment: full word
                                 0-569.23$  0-590.11@  0-688.19  0-751.26
 
istart                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-627.7@  0-636.12  0-638.17  0-645.27  0-654.31  0-656.20  0-670.21  0-670.41  0-674.36  0-693.37
                                 0-702.7@  0-702.17
 
iter                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-625.7@  0-634.7@  0-634.15
 
iwdptr                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-602.7@  0-688.32  0-689.7@  0-689.17  0-750.16  0-752.22
 
iwork                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-555.23$  0-509.26  0-645.21  0-654.25  0-670.15@  0-670.35  0-674.30  0-693.31
 
ix                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-750.7@  0-751.43  0-779.7@  0-780.43
 
kbds                             Automatic, Integer(4) (1:22), Offset: 0, Alignment: full word
                                 0-554.27$  0-608.7@  0-610.7@  0-612.7@  0-614.7@  0-621.7@  0-666.7@  0-666.19  0-672.42  0-674.51
                                 0-676.26  0-695.11@  0-695.23  0-739.25  0-743.25  0-762.7@  0-764.25  0-775.7@  0-777.25  0-829.25
 
kount                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-629.7@  0-647.12@  0-647.20
 
kpts                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-639.12@  0-650.12@  0-661.12@  0-669.27  0-693.60  0-694.30  0-695.34  0-701.26  0-702.26
 
kwide                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-551.30$  0-510.47  0-621.19  0-679.19@  0-680.35  0-686.11@  0-688.26  0-692.11  0-693.52
                                 0-694.37
 
len                              Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-554.23$  0-510.18  0-788.7@  0-790.17
 
lenbds                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-552.23$  0-510.22  0-790.7@  0-795.25
 
lk                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-669.19@  0-670.28  0-670.48
 
lw                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-818.23  0-819.15
 
mod                              Pure Intrinsic
                                 0-757.11  0-758.30  0-769.11  0-770.30  0-782.16
 
mxdiff                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-640.12@  0-649.12@  0-660.12@  0-668.11  0-678.11  0-680.19
 
nleft                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-782.7@  0-783.11  0-784.11@  0-784.25  0-785.27  0-802.25
 
nmax                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-654.43  0-660.22
 
nmin                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-654.48  0-660.29  0-670.54  0-672.30
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-509.38  0-636.22  0-638.27  0-645.34  0-654.38
 
pds                              Reference argument, Character(1) (1:*), Offset: 0, Alignment: byte
                                 0-547.32$  0-510.29
 
refnce                           Reference argument, Real(4), Offset: 0, Alignment: full word
                                 0-549.23$  0-510.33  0-820.28  0-822.28
 
sbyte                            External Subroutine
                                 0-672.16  0-674.16  0-688.12  0-700.12  0-718.12  0-720.12  0-722.12  0-724.12  0-726.12  0-728.12
                                 0-730.12  0-732.12  0-739.12  0-743.12  0-746.12  0-764.12  0-777.12  0-795.12  0-797.12  0-798.12
                                 0-799.12  0-800.12  0-802.12  0-805.16  0-808.16  0-810.12  0-824.16  0-825.16  0-829.12
 
sbytes                           External Subroutine
                                 0-693.16  0-751.12  0-755.12  0-767.12  0-780.12
 
w3fi01                           External Subroutine
                                 0-818.16
 
w3fi76                           External Subroutine
                                 0-820.20  0-822.20
 
** fi7501   === End of Compilation 2 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
        833 |      SUBROUTINE FI7502 (IWORK,ISTART,NPTS,ISAME)
        834 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
        835 |C                .      .    .                                       .
        836 |C SUBPROGRAM:    FI7502      SECOND ORDER SAME VALUE COLLECTION
        837 |C   PRGMMR: CAVANAUGH        ORG: W/NMC42    DATE: 93-06-23
        838 |C
        839 |C ABSTRACT: COLLECT SEQUENTIAL SAME VALUES FOR PROCESSING
        840 |C   AS SECOND ORDER VALUE FOR GRIB MESSAGES.
        841 |C
        842 |C PROGRAM HISTORY LOG:
        843 |C   93-06-23  CAVANAUGH
        844 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
        845 |C
        846 |C USAGE:    CALL FI7502 (IWORK,ISTART,NPTS,ISAME)
        847 |C   INPUT ARGUMENT LIST:
        848 |C     IWORK    - ARRAY CONTAINING SOURCE DATA
        849 |C     ISTART   - STARTING LOCATION FOR THIS TEST
        850 |C     NPTS     - NUMBER OF POINTS IN IWORK
        851 |C
        852 |C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
        853 |C     ISAME    - NUMBER OF SEQUENTIAL POINTS HAVING THE SAME VALUE
        854 |C
        855 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
        856 |C
        857 |C ATTRIBUTES:
        858 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
        859 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
        860 |C
        861 |C$$$
        862 |      INTEGER        IWORK(*)
        863 |      INTEGER        ISTART
        864 |      INTEGER        ISAME
        865 |      INTEGER        K
        866 |      INTEGER        NPTS
        867 |C  -------------------------------------------------------------
        868 |      ISAME  = 0
        869 |      DO 100 K = ISTART, NPTS
        870 |          IF (IWORK(K).NE.IWORK(ISTART)) THEN
        871 |              RETURN
        872 |          END IF
        873 |          ISAME  = ISAME + 1
        874 |  100 CONTINUE
        875 |      RETURN
        876 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
fi7502                           Subroutine
                                 0-833.18$
 
isame                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-864.22$  0-833.44  0-868.7@  0-873.11@  0-873.20
 
istart                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-863.22$  0-833.32  0-869.18  0-870.33
 
iwork                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-862.22$  0-833.26  0-870.15  0-870.27
 
k                                Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-865.22$  0-869.14@  0-870.21
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-866.22$  0-833.39  0-869.26
 
** fi7502   === End of Compilation 3 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
        877 |      SUBROUTINE FI7503 (IWORK,IPFLD,NPTS,IBDSFL,BDS11,
        878 |     *           LEN,LENBDS,PDS,REFNCE,ISCAL2,KWIDE,IGDS)
        879 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
        880 |C                .      .    .                                       .
        881 |C SUBPROGRAM:    FI7501      ROW BY ROW, COL BY COL PACKING
        882 |C   PRGMMR: CAVANAUGH        ORG: W/NMC42    DATE: 94-05-20
        883 |C
        884 |C ABSTRACT: PERFORM ROW BY ROW OR COLUMN BY COLUMN PACKING
        885 |C   GENERATING ALL BDS INFORMATION.
        886 |C
        887 |C PROGRAM HISTORY LOG:
        888 |C   93-08-06  CAVANAUGH
        889 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
        890 |C
        891 |C USAGE:    CALL FI7503 (IWORK,IPFLD,NPTS,IBDSFL,BDS11,
        892 |C    *           LEN,LENBDS,PDS,REFNCE,ISCAL2,KWIDE,IGDS)
        893 |C   INPUT ARGUMENT LIST:
        894 |C     IWORK    - INTEGER SOURCE ARRAY
        895 |C     NPTS     - NUMBER OF POINTS IN IWORK
        896 |C     IBDSFL   - FLAGS
        897 |C
        898 |C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
        899 |C     IPFLD    - CONTAINS BDS FROM BYTE 12 ON
        900 |C     BDS11    - CONTAINS FIRST 11 BYTES FOR BDS
        901 |C     LEN      - NUMBER OF BYTES FROM 12 ON
        902 |C     LENBDS   - TOTAL LENGTH OF BDS
        903 |C
        904 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
        905 |C
        906 |C ATTRIBUTES:
        907 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
        908 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
        909 |C
        910 |C$$$
        911 |      CHARACTER*1     BDS11(*),PDS(*)
        912 |C
        913 |      REAL            REFNCE
        914 |C
        915 |      INTEGER         ISCAL2,KWIDE
        916 |      INTEGER         LENBDS
        917 |      INTEGER         IPFLD(*),IGDS(*)
        918 |      INTEGER         LEN,KBDS(22)
        919 |      INTEGER         IWORK(*)
        920 |C                        OCTET NUMBER IN SECTION, FIRST ORDER PACKING
        921 |C     INTEGER         KBDS(12)
        922 |C                        FLAGS
        923 |      INTEGER         IBDSFL(*)
        924 |C                        EXTENDED FLAGS
        925 |C     INTEGER         KBDS(14)
        926 |C                        OCTET NUMBER FOR SECOND ORDER PACKING
        927 |C     INTEGER         KBDS(15)
        928 |C                        NUMBER OF FIRST ORDER VALUES
        929 |C     INTEGER         KBDS(17)
        930 |C                        NUMBER OF SECOND ORDER PACKED VALUES
        931 |C     INTEGER         KBDS(19)
        932 |C                        WIDTH OF SECOND ORDER PACKING
        933 |      INTEGER         ISOWID(50000)
        934 |C                        SECONDARY BIT MAP
        935 |      INTEGER         ISOBMP(8200)
        936 |C                        FIRST ORDER PACKED VALUES
        937 |      INTEGER         IFOVAL(50000)
        938 |C                        SECOND ORDER PACKED VALUES
        939 |      INTEGER         ISOVAL(100000)
        940 |C
        941 |C     INTEGER         KBDS(11)
        942 |C  ----------------------------------
        943 |C                       INITIALIZE ARRAYS
        944 |      DO 100 I = 1, 50000
        945 |          ISOWID(I)  = 0
        946 |          IFOVAL(I)  = 0
        947 |  100 CONTINUE
        948 |C
        949 |      DO 101 I = 1, 8200
        950 |          ISOBMP(I)  = 0
        951 |  101 CONTINUE
        952 |      DO 102 I = 1, 100000
        953 |          ISOVAL(I)  = 0
        954 |  102 CONTINUE
        955 |C                      INITIALIZE POINTERS
        956 |C                            SECONDARY BIT WIDTH POINTER
        957 |      IWDPTR  = 0
        958 |C                            SECONDARY BIT MAP POINTER
        959 |      IBMP2P  = 0
        960 |C                            FIRST ORDER VALUE POINTER
        961 |      IFOPTR  = 0
        962 |C                            BYTE POINTER TO START OF 1ST ORDER VALUES
        963 |      KBDS(12)  = 0
        964 |C                            BYTE POINTER TO START OF 2ND ORDER VALUES
        965 |      KBDS(15)  = 0
        966 |C                            TO CONTAIN NUMBER OF FIRST ORDER VALUES
        967 |      KBDS(17)  = 0
        968 |C                            TO CONTAIN NUMBER OF SECOND ORDER VALUES
        969 |      KBDS(19)  = 0
        970 |C                            SECOND ORDER PACKED VALUE POINTER
        971 |      ISOPTR  = 0
        972 |C  =======================================================
        973 |C                         BUILD SECOND ORDER BIT MAP IN EITHER
        974 |C                         ROW BY ROW OR COL BY COL FORMAT
        975 |      IF (IAND(IGDS(13),32).NE.0) THEN
        976 |C                              COLUMN BY COLUMN
        977 |          KOUT  = IGDS(4)
        978 |          KIN   = IGDS(5)
        979 |C         PRINT *,'COLUMN BY COLUMN',KOUT,KIN
        980 |      ELSE
        981 |C                              ROW BY ROW
        982 |          KOUT  = IGDS(5)
        983 |          KIN   = IGDS(4)
        984 |C         PRINT *,'ROW BY ROW',KOUT,KIN
        985 |      END IF
        986 |      KBDS(17)  = KOUT
        987 |      KBDS(19)  = NPTS
        988 |C
        989 |C     DO 4100 J = 1, NPTS, 53
        990 |C         WRITE (6,4101) (IWORK(K),K=J,J+52)
        991 | 4101     FORMAT (1X,25I4)
        992 |C         PRINT *,' '
        993 |C4100 CONTINUE
        994 |C
        995 |C                             INITIALIZE BIT MAP POINTER
        996 |      IBMP2P = 0
        997 |C                             CONSTRUCT WORKING BIT MAP
        998 |      DO 2000 I = 1, KOUT
        999 |          DO 1000 J = 1, KIN
       1000 |              IF (J.EQ.1) THEN
       1001 |                  CALL SBYTE (ISOBMP,1,IBMP2P,1)
       1002 |              ELSE
       1003 |                  CALL SBYTE (ISOBMP,0,IBMP2P,1)
       1004 |              END IF
       1005 |              IBMP2P  = IBMP2P + 1
       1006 | 1000     CONTINUE
       1007 | 2000 CONTINUE
       1008 |      LEN  = IBMP2P / 32 + 1
       1009 |C     CALL BINARY(ISOBMP,LEN)
       1010 |C
       1011 |C                       PROCESS OUTER LOOP OF ROW BY ROW OR COL BY COL
       1012 |C
       1013 |      KPTR  = 1
       1014 |      KBDS(11)  = KWIDE
       1015 |      DO 6000 I = 1, KOUT
       1016 |C                       IN CURRENT ROW OR COL
       1017 |C                              FIND FIRST ORDER VALUE
       1018 |          JPTR  = KPTR
       1019 |          LOWEST  = IWORK(JPTR)
       1020 |          DO 4000 J = 1, KIN
       1021 |              IF (IWORK(JPTR).LT.LOWEST) THEN
       1022 |                  LOWEST = IWORK(JPTR)
       1023 |              END IF
       1024 |              JPTR  = JPTR + 1
       1025 | 4000     CONTINUE
       1026 |C                            SAVE FIRST ORDER VALUE
       1027 |          CALL SBYTE (IFOVAL,LOWEST,IFOPTR,KWIDE)
       1028 |          IFOPTR  = IFOPTR + KWIDE
       1029 |C         PRINT *,'FOVAL',I,LOWEST,KWIDE
       1030 |C                            SUBTRACT FIRST ORDER VALUE FROM OTHER VALS
       1031 |C                                         GETTING SECOND ORDER VALUES
       1032 |          JPTR  = KPTR
       1033 |          IBIG  = IWORK(JPTR) - LOWEST
       1034 |          DO 4200 J = 1, KIN
       1035 |              IWORK(JPTR)  = IWORK(JPTR) - LOWEST
       1036 |              IF (IWORK(JPTR).GT.IBIG) THEN
       1037 |                  IBIG  = IWORK(JPTR)
       1038 |              END IF
       1039 |              JPTR  = JPTR + 1
       1040 | 4200     CONTINUE
       1041 |C                            HOW MANY BITS TO CONTAIN LARGEST SECOND
       1042 |C                                         ORDER VALUE IN SEGMENT
       1043 |          CALL FI7505 (IBIG,NWIDE)
       1044 |C                            SAVE BIT WIDTH
       1045 |          CALL SBYTE (ISOWID,NWIDE,IWDPTR,8)
       1046 |          IWDPTR  = IWDPTR + 8
       1047 |C         PRINT *,I,'SOVAL',IBIG,' IN',NWIDE,' BITS'
       1048 |C         WRITE (6,4101) (IWORK(K),K=KPTR,KPTR+52)
       1049 |C                            SAVE SECOND ORDER VALUES OF THIS SEGMENT
       1050 |          DO 5000 J = 0, KIN-1
       1051 |              CALL SBYTE (ISOVAL,IWORK(KPTR+J),ISOPTR,NWIDE)
       1052 |              ISOPTR  = ISOPTR + NWIDE
       1053 | 5000     CONTINUE
       1054 |          KPTR    = KPTR + KIN
       1055 | 6000 CONTINUE
       1056 |C  =======================================================
       1057 |C                 CONCANTENATE ALL FIELDS FOR BDS
       1058 |C
       1059 |C                   REMAINDER GOES INTO IPFLD
       1060 |      IPTR  = 0
       1061 |C                               BYTES 12-13
       1062 |C                                          VALUE FOR N1
       1063 |C                                          LEAVE SPACE FOR THIS
       1064 |      IPTR   = IPTR + 16
       1065 |C                               BYTE 14
       1066 |C                                          EXTENDED FLAGS
       1067 |      CALL SBYTE (IPFLD,IBDSFL(5),IPTR,1)
       1068 |      IPTR  = IPTR + 1
       1069 |      CALL SBYTE (IPFLD,IBDSFL(6),IPTR,1)
       1070 |      IPTR  = IPTR + 1
       1071 |      CALL SBYTE (IPFLD,IBDSFL(7),IPTR,1)
       1072 |      IPTR  = IPTR + 1
       1073 |      CALL SBYTE (IPFLD,IBDSFL(8),IPTR,1)
       1074 |      IPTR  = IPTR + 1
       1075 |      CALL SBYTE (IPFLD,IBDSFL(9),IPTR,1)
       1076 |      IPTR  = IPTR + 1
       1077 |      CALL SBYTE (IPFLD,IBDSFL(10),IPTR,1)
       1078 |      IPTR  = IPTR + 1
       1079 |      CALL SBYTE (IPFLD,IBDSFL(11),IPTR,1)
       1080 |      IPTR  = IPTR + 1
       1081 |      CALL SBYTE (IPFLD,IBDSFL(12),IPTR,1)
       1082 |      IPTR  = IPTR + 1
       1083 |C                               BYTES 15-16
       1084 |C                 SKIP OVER VALUE  FOR N2
       1085 |      IPTR  = IPTR + 16
       1086 |C                               BYTES 17-18
       1087 |C                                     P1
       1088 |      CALL SBYTE (IPFLD,KBDS(17),IPTR,16)
       1089 |      IPTR  = IPTR + 16
       1090 |C                               BYTES 19-20
       1091 |C                                   P2
       1092 |      CALL SBYTE (IPFLD,KBDS(19),IPTR,16)
       1093 |      IPTR  = IPTR + 16
       1094 |C                               BYTE 21 - RESERVED LOCATION
       1095 |      CALL SBYTE (IPFLD,0,IPTR,8)
       1096 |      IPTR  = IPTR + 8
       1097 |C                               BYTES 22 - ?
       1098 |C                                      WIDTHS OF SECOND ORDER PACKING
       1099 |      IX    = (IWDPTR + 32) / 32
       1100 |      CALL SBYTES (IPFLD,ISOWID,IPTR,32,0,IX)
       1101 |      IPTR  = IPTR + IWDPTR
       1102 |C     PRINT *,'ISOWID',IWDPTR,IX
       1103 |C     CALL BINARY (ISOWID,IX)
       1104 |C
       1105 |C                     NO SECONDARY BIT MAP
       1106 |
       1107 |C                                         DETERMINE LOCATION FOR START
       1108 |C                                         OF FIRST ORDER PACKED VALUES
       1109 |      KBDS(12)  = IPTR / 8 + 12
       1110 |C                                        STORE LOCATION
       1111 |      CALL SBYTE (IPFLD,KBDS(12),0,16)
       1112 |C                                     MOVE IN FIRST ORDER PACKED VALUES
       1113 |      IPASS   = (IFOPTR + 32) / 32
       1114 |      CALL SBYTES (IPFLD,IFOVAL,IPTR,32,0,IPASS)
       1115 |      IPTR  = IPTR + IFOPTR
       1116 |C     PRINT *,'IFOVAL',IFOPTR,IPASS,KWIDE
       1117 |C     CALL BINARY (IFOVAL,IPASS)
       1118 |      IF (MOD(IPTR,8).NE.0) THEN
       1119 |          IPTR  = IPTR + 8 - MOD(IPTR,8)
       1120 |      END IF
       1121 |C     PRINT *,'IFOPTR =',IFOPTR,' ISOPTR =',ISOPTR
       1122 |C                DETERMINE LOCATION FOR START
       1123 |C                     OF SECOND ORDER VALUES
       1124 |      KBDS(15)  = IPTR / 8 + 12
       1125 |C                                   SAVE LOCATION OF SECOND ORDER VALUES
       1126 |      CALL SBYTE (IPFLD,KBDS(15),24,16)
       1127 |C                  MOVE IN SECOND ORDER PACKED VALUES
       1128 |      IX    = (ISOPTR + 32) / 32
       1129 |      CALL SBYTES (IPFLD,ISOVAL,IPTR,32,0,IX)
       1130 |      IPTR  = IPTR + ISOPTR
       1131 |C     PRINT *,'ISOVAL',ISOPTR,IX
       1132 |C     CALL BINARY (ISOVAL,IX)
       1133 |      NLEFT  = MOD(IPTR+88,16)
       1134 |      IF (NLEFT.NE.0) THEN
       1135 |          NLEFT  = 16 - NLEFT
       1136 |          IPTR   = IPTR + NLEFT
       1137 |      END IF
       1138 |C                                COMPUTE LENGTH OF DATA PORTION
       1139 |      LEN     = IPTR / 8
       1140 |C                                    COMPUTE LENGTH OF BDS
       1141 |      LENBDS  = LEN + 11
       1142 |C  -----------------------------------
       1143 |C                               BYTES 1-3
       1144 |C                                   THIS FUNCTION COMPLETED BELOW
       1145 |C                                   WHEN LENGTH OF BDS IS KNOWN
       1146 |      CALL SBYTE (BDS11,LENBDS,0,24)
       1147 |C                               BYTE  4
       1148 |      CALL SBYTE (BDS11,IBDSFL(1),24,1)
       1149 |      CALL SBYTE (BDS11,IBDSFL(2),25,1)
       1150 |      CALL SBYTE (BDS11,IBDSFL(3),26,1)
       1151 |      CALL SBYTE (BDS11,IBDSFL(4),27,1)
       1152 |C                              ENTER NUMBER OF FILL BITS
       1153 |      CALL SBYTE (BDS11,NLEFT,28,4)
       1154 |C                               BYTE  5-6
       1155 |      IF (ISCAL2.LT.0) THEN
       1156 |          CALL SBYTE (BDS11,1,32,1)
       1157 |          ISCAL2 = - ISCAL2
       1158 |      ELSE
       1159 |          CALL SBYTE (BDS11,0,32,1)
       1160 |      END IF
       1161 |      CALL SBYTE (BDS11,ISCAL2,33,15)
       1162 |C
       1163 |C$  FILL OCTET 7-10 WITH THE REFERENCE VALUE
       1164 |C   CONVERT THE FLOATING POINT OF YOUR MACHINE TO IBM370 32 BIT
       1165 |C   FLOATING POINT NUMBER
       1166 |C                                        REFERENCE VALUE
       1167 |C                                          FIRST TEST TO SEE IF
       1168 |C                                          ON 32 OR 64 BIT COMPUTER
       1169 |      CALL W3FI01(LW)
       1170 |      IF (LW.EQ.4) THEN
       1171 |          CALL W3FI76 (REFNCE,IEXP,IMANT,32)
       1172 |      ELSE
       1173 |          CALL W3FI76 (REFNCE,IEXP,IMANT,64)
       1174 |      END IF
       1175 |      CALL SBYTE (BDS11,IEXP,48,8)
       1176 |      CALL SBYTE (BDS11,IMANT,56,24)
       1177 |C
       1178 |C                               BYTE  11
       1179 |C
       1180 |      CALL SBYTE (BDS11,KBDS(11),80,8)
       1181 |C
       1182 |      KLEN  = LENBDS / 4 + 1
       1183 |C     PRINT *,'BDS11 LISTING',4,LENBDS
       1184 |C     CALL BINARY (BDS11,4)
       1185 |C     PRINT *,'IPFLD LISTING'
       1186 |C     CALL BINARY (IPFLD,KLEN)
       1187 |      RETURN
       1188 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
bds11                            Reference argument, Character(1) (1:*), Offset: 0, Alignment: byte
                                 0-911.23$  0-877.50  0-1146.19  0-1148.19  0-1149.19  0-1150.19  0-1151.19  0-1153.19  0-1156.23
                                 0-1159.23  0-1161.19  0-1175.19  0-1176.19  0-1180.19
 
fi7503                           Subroutine
                                 0-877.18$
 
fi7505                           External Subroutine
                                 0-1043.16
 
i                                Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-944.14@  0-945.18  0-946.18  0-949.14@  0-950.18  0-952.14@  0-953.18  0-998.15@  0-1015.15@
 
iand                             Pure Intrinsic
                                 0-975.11
 
ibdsfl                           Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-923.23$  0-877.43  0-1067.25  0-1069.25  0-1071.25  0-1073.25  0-1075.25  0-1077.25  0-1079.25
                                 0-1081.25  0-1148.25  0-1149.25  0-1150.25  0-1151.25
 
ibig                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1033.11@  0-1036.34  0-1037.19@  0-1043.24
 
ibmp2p                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-959.7@  0-996.7@  0-1001.40  0-1003.40  0-1005.15@  0-1005.25  0-1008.14
 
iexp                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1171.31  0-1173.31  0-1175.25
 
ifoptr                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-961.7@  0-1027.37  0-1028.11@  0-1028.21  0-1113.18  0-1115.22
 
ifoval                           Automatic, Integer(4) (1:50000), Offset: 0, Alignment: full word
                                 0-937.23$  0-946.11@  0-1027.23  0-1114.26
 
igds                             Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-917.32$  0-878.53  0-975.16  0-977.19  0-978.19  0-982.19  0-983.19
 
imant                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1171.36  0-1173.36  0-1176.25
 
ipass                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1113.7@  0-1114.43
 
ipfld                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-917.23$  0-877.32  0-1067.19  0-1069.19  0-1071.19  0-1073.19  0-1075.19  0-1077.19  0-1079.19
                                 0-1081.19  0-1088.19  0-1092.19  0-1095.19  0-1100.20  0-1111.19  0-1114.20  0-1126.19  0-1129.20
 
iptr                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1060.7@  0-1064.7@  0-1064.16  0-1067.35  0-1068.7@  0-1068.15  0-1069.35  0-1070.7@  0-1070.15
                                 0-1071.35  0-1072.7@  0-1072.15  0-1073.35  0-1074.7@  0-1074.15  0-1075.35  0-1076.7@  0-1076.15
                                 0-1077.36  0-1078.7@  0-1078.15  0-1079.36  0-1080.7@  0-1080.15  0-1081.36  0-1082.7@  0-1082.15
                                 0-1085.7@  0-1085.15  0-1088.34  0-1089.7@  0-1089.15  0-1092.34  0-1093.7@  0-1093.15  0-1095.27
                                 0-1096.7@  0-1096.15  0-1100.33  0-1101.7@  0-1101.15  0-1109.19  0-1114.33  0-1115.7@  0-1115.15
                                 0-1118.15  0-1119.11@  0-1119.19  0-1119.34  0-1124.19  0-1129.33  0-1130.7@  0-1130.15  0-1133.20
                                 0-1136.11@  0-1136.20  0-1139.17
 
iscal2                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-915.23$  0-878.40  0-1155.11  0-1157.11@  0-1157.22  0-1161.25
 
isobmp                           Automatic, Integer(4) (1:8200), Offset: 0, Alignment: full word
                                 0-935.23$  0-950.11@  0-1001.31  0-1003.31
 
isoptr                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-971.7@  0-1051.48  0-1052.15@  0-1052.25  0-1128.16  0-1130.22
 
isoval                           Automatic, Integer(4) (1:100000), Offset: 0, Alignment: full word
                                 0-939.23$  0-953.11@  0-1051.27  0-1129.26
 
isowid                           Automatic, Integer(4) (1:50000), Offset: 0, Alignment: full word
                                 0-933.23$  0-945.11@  0-1045.23  0-1100.26
 
iwdptr                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-957.7@  0-1045.36  0-1046.11@  0-1046.21  0-1099.16  0-1101.22
 
iwork                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-919.23$  0-877.26  0-1019.21  0-1021.19  0-1022.28  0-1033.19  0-1035.15@  0-1035.30  0-1036.19
                                 0-1037.27  0-1051.34
 
ix                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1099.7@  0-1100.43  0-1128.7@  0-1129.43
 
j                                Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-999.19@  0-1000.19  0-1020.19@  0-1034.19@  0-1050.19@  0-1051.45
 
jptr                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1018.11@  0-1019.27  0-1021.25  0-1022.34  0-1024.15@  0-1024.23  0-1032.11@  0-1033.25
                                 0-1035.21  0-1035.36  0-1036.25  0-1037.33  0-1039.15@  0-1039.23
 
kbds                             Automatic, Integer(4) (1:22), Offset: 0, Alignment: full word
                                 0-918.27$  0-963.7@  0-965.7@  0-967.7@  0-969.7@  0-986.7@  0-987.7@  0-1014.7@  0-1088.25
                                 0-1092.25  0-1109.7@  0-1111.25  0-1124.7@  0-1126.25  0-1180.25
 
kin                              Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-978.11@  0-983.11@  0-999.26  0-1020.26  0-1034.26  0-1050.26  0-1054.28
 
klen                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1182.7@
 
kout                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-977.11@  0-982.11@  0-986.19  0-998.22  0-1015.22
 
kptr                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1013.7@  0-1018.19  0-1032.19  0-1051.40  0-1054.11@  0-1054.21
 
kwide                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-915.30$  0-878.47  0-1014.19  0-1027.44  0-1028.30
 
len                              Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-918.23$  0-878.18  0-1008.7@  0-1139.7@  0-1141.17
 
lenbds                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-916.23$  0-878.22  0-1141.7@  0-1146.25  0-1182.15
 
lowest                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1019.11@  0-1021.34  0-1022.19@  0-1027.30  0-1033.33  0-1035.44
 
lw                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1169.19  0-1170.11
 
mod                              Pure Intrinsic
                                 0-1118.11  0-1119.30  0-1133.16
 
nleft                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1133.7@  0-1134.11  0-1135.11@  0-1135.25  0-1136.27  0-1153.25
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-877.38  0-987.19
 
nwide                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1043.29  0-1045.30  0-1051.55  0-1052.34
 
pds                              Reference argument, Character(1) (1:*), Offset: 0, Alignment: byte
                                 0-911.32$  0-878.29
 
refnce                           Reference argument, Real(4), Offset: 0, Alignment: full word
                                 0-913.23$  0-878.33  0-1171.24  0-1173.24
 
sbyte                            External Subroutine
                                 0-1001.24  0-1003.24  0-1027.16  0-1045.16  0-1051.20  0-1067.12  0-1069.12  0-1071.12  0-1073.12
                                 0-1075.12  0-1077.12  0-1079.12  0-1081.12  0-1088.12  0-1092.12  0-1095.12  0-1111.12  0-1126.12
                                 0-1146.12  0-1148.12  0-1149.12  0-1150.12  0-1151.12  0-1153.12  0-1156.16  0-1159.16  0-1161.12
                                 0-1175.12  0-1176.12  0-1180.12
 
sbytes                           External Subroutine
                                 0-1100.12  0-1114.12  0-1129.12
 
w3fi01                           External Subroutine
                                 0-1169.12
 
w3fi76                           External Subroutine
                                 0-1171.16  0-1173.16
 
** fi7503   === End of Compilation 4 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
       1189 |      SUBROUTINE FI7505 (N,NBITS)
       1190 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
       1191 |C                .      .    .                                       .
       1192 |C SUBPROGRAM:    FI7505      DETERMINE NUMBER OF BITS TO CONTAIN VALUE
       1193 |C   PRGMMR: CAVANAUGH        ORG: W/NMC42    DATE: 93-06-23
       1194 |C
       1195 |C ABSTRACT: CALCULATE NUMBER OF BITS TO CONTAIN VALUE N, WITH A
       1196 |C            MAXIMUM OF 32 BITS.
       1197 |C
       1198 |C PROGRAM HISTORY LOG:
       1199 |C   93-06-23  CAVANAUGH
       1200 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
       1201 |C
       1202 |C USAGE:    CALL FI7505 (N,NBITS)
       1203 |C   INPUT ARGUMENT LIST:
       1204 |C     N        - INTEGER VALUE
       1205 |C
       1206 |C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
       1207 |C     NBITS    - NUMBER OF BITS TO CONTAIN N
       1208 |C
       1209 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
       1210 |C
       1211 |C ATTRIBUTES:
       1212 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
       1213 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
       1214 |C
       1215 |C$$$
       1216 |      INTEGER        N,NBITS
       1217 |      INTEGER        IBITS(31)
       1218 |C
       1219 |      DATA           IBITS/1,3,7,15,31,63,127,255,511,1023,2047,
       1220 |     *               4095,8191,16383,32767,65535,131071,262143,
       1221 |     *               524287,1048575,2097151,4194303,8388607,
       1222 |     *               16777215,33554431,67108863,134217727,268435455,
       1223 |     *               536870911,1073741823,2147483647/
       1224 |C  ----------------------------------------------------------------
       1225 |C
       1226 |      DO 1000 NBITS = 1, 31
       1227 |          IF (N.LE.IBITS(NBITS)) THEN
       1228 |              RETURN
       1229 |          END IF
       1230 | 1000 CONTINUE
       1231 |      RETURN
       1232 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
fi7505                           Subroutine
                                 0-1189.18$
 
ibits                            Static, Integer(4) (1:31), Offset: 0, Alignment: full word
                                 0-1217.22$  0-1219.22*  0-1227.20
 
n                                Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1216.22$  0-1189.26  0-1227.15
 
nbits                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1216.24$  0-1189.28  0-1226.15@  0-1227.26
 
** fi7505   === End of Compilation 5 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
       1233 |      SUBROUTINE FI7513 (IWORK,ISTART,NPTS,MAX,MIN,INRNGE)
       1234 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
       1235 |C                .      .    .                                       .
       1236 |C SUBPROGRAM:    FI7513      SELECT BLOCK OF DATA FOR PACKING
       1237 |C   PRGMMR: CAVANAUGH        ORG: W/NMC42    DATE: 94-01-21
       1238 |C
       1239 |C ABSTRACT: SELECT A BLOCK OF DATA FOR PACKING
       1240 |C
       1241 |C PROGRAM HISTORY LOG:
       1242 |C   94-01-21  CAVANAUGH
       1243 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
       1244 |C
       1245 |C USAGE:    CALL FI7513 (IWORK,ISTART,NPTS,MAX,MIN,INRNGE)
       1246 |C   INPUT ARGUMENT LIST:
       1247 |C     *        - RETURN ADDRESS IF ENCOUNTER SET OF SAME VALUES
       1248 |C     IWORK    -
       1249 |C     ISTART   -
       1250 |C     NPTS     -
       1251 |C
       1252 |C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
       1253 |C     MAX      -
       1254 |C     MIN      -
       1255 |C     INRNGE   -
       1256 |C
       1257 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
       1258 |C
       1259 |C ATTRIBUTES:
       1260 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
       1261 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
       1262 |C
       1263 |C$$$
       1264 |      INTEGER        IWORK(*),NPTS,ISTART,INRNGE,INRNGA,INRNGB
       1265 |      INTEGER        MAX,MIN,MXVAL,MAXB,MINB,MXVALB
       1266 |      INTEGER        IBITS(31)
       1267 |C
       1268 |      DATA           IBITS/1,3,7,15,31,63,127,255,511,1023,2047,
       1269 |     *               4095,8191,16383,32767,65535,131071,262143,
       1270 |     *               524287,1048575,2097151,4194303,8388607,
       1271 |     *               16777215,33554431,67108863,134217727,268435455,
       1272 |     *               536870911,1073741823,2147483647/
       1273 |C  ----------------------------------------------------------------
       1274 |C                        IDENTIFY NEXT BLOCK OF DATA FOR PACKING AND
       1275 |C                           RETURN TO CALLER
       1276 |C  ********************************************************************
       1277 |      ISTRTA  = ISTART
       1278 |C
       1279 |C                     GET BLOCK A
       1280 |      CALL FI7516 (IWORK,NPTS,INRNGA,ISTRTA,
       1281 |     *                                  MAX,MIN,MXVAL,LWIDE)
       1282 |C  ********************************************************************
       1283 |C
       1284 |      ISTRTB  = ISTRTA + INRNGA
       1285 | 2000 CONTINUE
       1286 |C                         IF HAVE PROCESSED ALL DATA, RETURN
       1287 |      IF (ISTRTB.GT.NPTS) THEN
       1288 |C                         NO MORE DATA TO LOOK AT
       1289 |          INRNGE  = INRNGA
       1290 |          RETURN
       1291 |      END IF
       1292 |C                     GET BLOCK B
       1293 |      CALL FI7502 (IWORK,ISTRTB,NPTS,ISAME)
       1294 |      IF (ISAME.GE.15) THEN
       1295 |C         PRINT *,'BLOCK B HAS ALL IDENTICAL VALUES'
       1296 |C         PRINT *,'BLOCK A HAS INRNGE =',INRNGA
       1297 |C                     BLOCK B CONTAINS ALL IDENTICAL VALUES
       1298 |          INRNGE  = INRNGA
       1299 |C                     EXIT WITH BLOCK A
       1300 |          RETURN
       1301 |      END IF
       1302 |C                     GET BLOCK B
       1303 |C
       1304 |      ISTRTB  = ISTRTA + INRNGA
       1305 |      CALL FI7516 (IWORK,NPTS,INRNGB,ISTRTB,
       1306 |     *                                  MAXB,MINB,MXVALB,LWIDEB)
       1307 |C     PRINT *,'BLOCK A',INRNGA,' BLOCK B',INRNGB
       1308 |C  ********************************************************************
       1309 |C                     PERFORM TREND ANALYSIS TO DETERMINE
       1310 |C                     IF DATA COLLECTION CAN BE IMPROVED
       1311 |C
       1312 |      KTRND  = LWIDE - LWIDEB
       1313 |C     PRINT *,'TREND',LWIDE,LWIDEB
       1314 |      IF (KTRND.LE.0) THEN
       1315 |C         PRINT *,'BLOCK A - SMALLER, SHOULD EXTEND INTO BLOCK B'
       1316 |          MXVAL   = IBITS(LWIDE)
       1317 |C
       1318 |C                     IF BLOCK A REQUIRES THE SAME OR FEWER BITS
       1319 |C                             LOOK AHEAD
       1320 |C                        AND GATHER THOSE DATA POINTS THAT CAN
       1321 |C                        BE RETAINED IN BLOCK A
       1322 |C                        BECAUSE THIS BLOCK OF DATA
       1323 |C                            USES FEWER BITS
       1324 |C
       1325 |          CALL FI7518 (IRET,IWORK,NPTS,ISTRTA,INRNGA,INRNGB,
       1326 |     *                          MAX,MIN,LWIDE,MXVAL)
       1327 |          IF(IRET.EQ.1) GO TO 8000
       1328 |C         PRINT *,'18 INRNGA IS NOW ',INRNGA
       1329 |          IF (INRNGB.LT.20) THEN
       1330 |              RETURN
       1331 |          ELSE
       1332 |              GO TO 2000
       1333 |          END IF
       1334 |      ELSE
       1335 |C         PRINT *,'BLOCK A - LARGER, B SHOULD EXTEND BACK INTO A'
       1336 |          MXVALB  = IBITS(LWIDEB)
       1337 |C
       1338 |C                     IF BLOCK B REQUIRES FEWER BITS
       1339 |C                             LOOK BACK
       1340 |C                            SHORTEN BLOCK A BECAUSE NEXT BLOCK OF DATA
       1341 |C                            USES FEWER BITS
       1342 |C
       1343 |          CALL FI7517 (IRET,IWORK,NPTS,ISTRTB,INRNGA,
       1344 |     *                               MAXB,MINB,LWIDEB,MXVALB)
       1345 |          IF(IRET.EQ.1) GO TO 8000
       1346 |C         PRINT *,'17 INRNGA IS NOW ',INRNGA
       1347 |      END IF
       1348 |C
       1349 |C                           PACK UP BLOCK A
       1350 |C                           UPDATA POINTERS
       1351 | 8000 CONTINUE
       1352 |      INRNGE  = INRNGA
       1353 |C                           GET NEXT BLOCK A
       1354 | 9000 CONTINUE
       1355 |      RETURN
       1356 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
fi7502                           External Subroutine
                                 0-1293.12
 
fi7513                           Subroutine
                                 0-1233.18$
 
fi7516                           External Subroutine
                                 0-1280.12  0-1305.12
 
fi7517                           External Subroutine
                                 0-1343.16
 
fi7518                           External Subroutine
                                 0-1325.16
 
ibits                            Static, Integer(4) (1:31), Offset: 0, Alignment: full word
                                 0-1266.22$  0-1268.22*  0-1316.21  0-1336.21
 
inrnga                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1264.50$  0-1280.31  0-1284.26  0-1289.21  0-1298.21  0-1304.26  0-1325.47  0-1343.47  0-1352.17
 
inrngb                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1264.57$  0-1305.31  0-1325.54  0-1329.15
 
inrnge                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1264.43$  0-1233.52  0-1289.11@  0-1298.11@  0-1352.7@
 
iret                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1325.24  0-1327.14  0-1343.24  0-1345.14
 
isame                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1293.38  0-1294.11
 
istart                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1264.36$  0-1233.32  0-1277.17
 
istrta                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1277.7@  0-1280.38  0-1284.17  0-1304.17  0-1325.40
 
istrtb                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1284.7@  0-1287.11  0-1293.26  0-1304.7@  0-1305.38  0-1343.40
 
iwork                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-1264.22$  0-1233.26  0-1280.20  0-1293.20  0-1305.20  0-1325.29  0-1343.29
 
ktrnd                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1312.7@  0-1314.11
 
lwide                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1281.55  0-1312.16  0-1316.27  0-1326.41
 
lwideb                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1306.58  0-1312.24  0-1336.27  0-1344.48
 
max                              Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1265.22$  0-1233.44  0-1281.41  0-1326.33
 
maxb                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1265.36$  0-1306.41  0-1344.38
 
min                              Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1265.26$  0-1233.48  0-1281.45  0-1326.37
 
minb                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1265.41$  0-1306.46  0-1344.43
 
mxval                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1265.30$  0-1281.49  0-1316.11@  0-1326.47
 
mxvalb                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1265.46$  0-1306.51  0-1336.11@  0-1344.55
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1264.31$  0-1233.39  0-1280.26  0-1287.21  0-1293.33  0-1305.26  0-1325.35  0-1343.35
 
** fi7513   === End of Compilation 6 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
       1357 |      SUBROUTINE FI7516 (IWORK,NPTS,INRNG,ISTART,MAX,MIN,MXVAL,LWIDTH)
       1358 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
       1359 |C                .      .    .                                       .
       1360 |C SUBPROGRAM:    FI7516      SCAN NUMBER OF POINTS
       1361 |C   PRGMMR: CAVANAUGH        ORG: W/NMC42    DATE: 94-01-21
       1362 |C
       1363 |C ABSTRACT: SCAN FORWARD FROM CURRENT POSITION. COLLECT POINTS AND
       1364 |C           DETERMINE MAXIMUM AND MINIMUM VALUES AND THE NUMBER
       1365 |C           OF POINTS THAT ARE INCLUDED. FORWARD SEARCH IS TERMINATED
       1366 |C           BY ENCOUNTERING A SET OF IDENTICAL VALUES, BY REACHING
       1367 |C           THE NUMBER OF POINTS SELECTED OR BY REACHING THE END
       1368 |C           OF DATA.
       1369 |C
       1370 |C PROGRAM HISTORY LOG:
       1371 |C   94-01-21  CAVANAUGH
       1372 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
       1373 |C
       1374 |C USAGE:    CALL FI7516 (IWORK,NPTS,INRNG,ISTART,MAX,MIN,MXVAL,LWIDTH)
       1375 |C   INPUT ARGUMENT LIST:
       1376 |C     *        - RETURN ADDRESS IF ENCOUNTER SET OF SAME VALUES
       1377 |C     IWORK    - DATA ARRAY
       1378 |C     NPTS     - NUMBER OF POINTS IN DATA ARRAY
       1379 |C     ISTART   - STARTING LOCATION IN DATA
       1380 |C
       1381 |C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
       1382 |C     INRNG    - NUMBER OF POINTS SELECTED
       1383 |C     MAX      - MAXIMUM VALUE OF POINTS
       1384 |C     MIN      - MINIMUM VALUE OF POINTS
       1385 |C     MXVAL    - MAXIMUM VALUE THAT CAN BE CONTAINED IN LWIDTH BITS
       1386 |C     LWIDTH   - NUMBER OF BITS TO CONTAIN MAX DIFF
       1387 |C
       1388 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
       1389 |C
       1390 |C ATTRIBUTES:
       1391 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
       1392 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
       1393 |C
       1394 |C$$$
       1395 |      INTEGER        IWORK(*),NPTS,ISTART,INRNG,MAX,MIN,LWIDTH,MXVAL
       1396 |      INTEGER        IBITS(31)
       1397 |C
       1398 |      DATA           IBITS/1,3,7,15,31,63,127,255,511,1023,2047,
       1399 |     *               4095,8191,16383,32767,65535,131071,262143,
       1400 |     *               524287,1048575,2097151,4194303,8388607,
       1401 |     *               16777215,33554431,67108863,134217727,268435455,
       1402 |     *               536870911,1073741823,2147483647/
       1403 |C  ----------------------------------------------------------------
       1404 |C
       1405 |      INRNG  = 1
       1406 |      JQ        = ISTART + 19
       1407 |      MAX       = IWORK(ISTART)
       1408 |      MIN       = IWORK(ISTART)
       1409 |      DO 1000 I = ISTART+1, JQ
       1410 |          CALL FI7502 (IWORK,I,NPTS,ISAME)
       1411 |          IF (ISAME.GE.15) THEN
       1412 |              GO TO 5000
       1413 |          END IF
       1414 |          INRNG  = INRNG + 1
       1415 |          IF (IWORK(I).GT.MAX) THEN
       1416 |              MAX  = IWORK(I)
       1417 |          ELSE IF (IWORK(I).LT.MIN) THEN
       1418 |              MIN  = IWORK(I)
       1419 |          END IF
       1420 | 1000 CONTINUE
       1421 | 5000 CONTINUE
       1422 |      KRNG   = MAX - MIN
       1423 |C
       1424 |      DO 9000 LWIDTH = 1, 31
       1425 |          IF (KRNG.LE.IBITS(LWIDTH)) THEN
       1426 |C             PRINT *,'RETURNED',INRNG,' VALUES'
       1427 |              RETURN
       1428 |          END IF
       1429 | 9000 CONTINUE
       1430 |      RETURN
       1431 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
fi7502                           External Subroutine
                                 0-1410.16
 
fi7516                           Subroutine
                                 0-1357.18$
 
i                                Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1409.15@  0-1410.30  0-1415.21  0-1416.28  0-1417.26  0-1418.28
 
ibits                            Static, Integer(4) (1:31), Offset: 0, Alignment: full word
                                 0-1396.22$  0-1398.22*  0-1425.23
 
inrng                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1395.43$  0-1357.37  0-1405.7@  0-1414.11@  0-1414.20
 
isame                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1410.37  0-1411.15
 
istart                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1395.36$  0-1357.43  0-1406.19  0-1407.25  0-1408.25  0-1409.19
 
iwork                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-1395.22$  0-1357.26  0-1407.19  0-1408.19  0-1410.24  0-1415.15  0-1416.22  0-1417.20  0-1418.22
 
jq                               Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1406.7@  0-1409.29
 
krng                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1422.7@  0-1425.15
 
lwidth                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1395.57$  0-1357.64  0-1424.15@  0-1425.29
 
max                              Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1395.49$  0-1357.50  0-1407.7@  0-1415.27  0-1416.15@  0-1422.16
 
min                              Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1395.53$  0-1357.54  0-1408.7@  0-1417.32  0-1418.15@  0-1422.22
 
mxval                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1395.64$  0-1357.58
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1395.31$  0-1357.32  0-1410.32
 
** fi7516   === End of Compilation 7 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
       1432 |      SUBROUTINE FI7517 (IRET,IWORK,NPTS,ISTRTB,INRNGA,
       1433 |     *                           MAXB,MINB,MXVALB,LWIDEB)
       1434 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
       1435 |C                .      .    .                                       .
       1436 |C SUBPROGRAM:    FI7517      SCAN BACKWARD
       1437 |C   PRGMMR: CAVANAUGH        ORG: W/NMC42    DATE: 94-01-21
       1438 |C
       1439 |C ABSTRACT: SCAN BACKWARDS UNTIL A VALUE EXCEEDS RANGE OF GROUP B
       1440 |C           THIS MAY SHORTEN GROUP A
       1441 |C
       1442 |C PROGRAM HISTORY LOG:
       1443 |C   94-01-21  CAVANAUGH
       1444 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
       1445 |C   98-06-17  IREDELL     REMOVED ALTERNATE RETURN
       1446 |C
       1447 |C USAGE:    CALL FI7517 (IRET,IWORK,NPTS,ISTRTB,INRNGA,
       1448 |C    *                           MAXB,MINB,MXVALB,LWIDEB)
       1449 |C   INPUT ARGUMENT LIST:
       1450 |C     IWORK    -
       1451 |C     ISTRTB   -
       1452 |C     NPTS     -
       1453 |C     INRNGA   -
       1454 |C
       1455 |C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
       1456 |C     IRET     -
       1457 |C     JLAST    -
       1458 |C     MAXB     -
       1459 |C     MINB     -
       1460 |C     LWIDTH   - NUMBER OF BITS TO CONTAIN MAX DIFF
       1461 |C
       1462 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
       1463 |C
       1464 |C ATTRIBUTES:
       1465 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
       1466 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
       1467 |C
       1468 |C$$$
       1469 |      INTEGER        IWORK(*),NPTS,ISTRTB,INRNGA
       1470 |      INTEGER        MAXB,MINB,LWIDEB,MXVALB
       1471 |      INTEGER        IBITS(31)
       1472 |C
       1473 |      DATA           IBITS/1,3,7,15,31,63,127,255,511,1023,2047,
       1474 |     *               4095,8191,16383,32767,65535,131071,262143,
       1475 |     *               524287,1048575,2097151,4194303,8388607,
       1476 |     *               16777215,33554431,67108863,134217727,268435455,
       1477 |     *               536870911,1073741823,2147483647/
       1478 |C  ----------------------------------------------------------------
       1479 |      IRET=0
       1480 |C     PRINT *,'          FI7517'
       1481 |      NPOS  = ISTRTB - 1
       1482 |      ITST  = 0
       1483 |      KSET  = INRNGA
       1484 |C
       1485 | 1000 CONTINUE
       1486 |C     PRINT *,'TRY NPOS',NPOS,IWORK(NPOS),MAXB,MINB
       1487 |      ITST  = ITST + 1
       1488 |      IF (ITST.LE.KSET) THEN
       1489 |          IF (IWORK(NPOS).GT.MAXB) THEN
       1490 |              IF ((IWORK(NPOS)-MINB).GT.MXVALB) THEN
       1491 |C                 PRINT *,'WENT OUT OF RANGE AT',NPOS
       1492 |                  IRET=1
       1493 |                  RETURN
       1494 |              ELSE
       1495 |                  MAXB    = IWORK(NPOS)
       1496 |              END IF
       1497 |          ELSE IF (IWORK(NPOS).LT.MINB) THEN
       1498 |              IF ((MAXB-IWORK(NPOS)).GT.MXVALB) THEN
       1499 |C                 PRINT *,'WENT OUT OF RANGE AT',NPOS
       1500 |                  IRET=1
       1501 |                  RETURN
       1502 |              ELSE
       1503 |                  MINB    = IWORK(NPOS)
       1504 |              END IF
       1505 |          END IF
       1506 |          INRNGA  = INRNGA - 1
       1507 |          NPOS  = NPOS - 1
       1508 |          GO TO 1000
       1509 |      END IF
       1510 |C  ----------------------------------------------------------------
       1511 |C
       1512 | 9000 CONTINUE
       1513 |      RETURN
       1514 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
fi7517                           Subroutine
                                 0-1432.18$
 
ibits                            Static, Integer(4) (1:31), Offset: 0, Alignment: full word
                                 0-1471.22$  0-1473.22*
 
inrnga                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1469.43$  0-1432.49  0-1483.15  0-1506.11@  0-1506.21
 
iret                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1432.26  0-1479.7@  0-1492.19@  0-1500.19@
 
istrtb                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1469.36$  0-1432.42  0-1481.15
 
itst                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1482.7@  0-1487.7@  0-1487.15  0-1488.11
 
iwork                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-1469.22$  0-1432.31  0-1489.15  0-1490.20  0-1495.29  0-1497.20  0-1498.25  0-1503.29
 
kset                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1483.7@  0-1488.19
 
lwideb                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1470.32$  0-1433.51
 
maxb                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1470.22$  0-1433.34  0-1489.30  0-1495.19@  0-1498.20
 
minb                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1470.27$  0-1433.39  0-1490.32  0-1497.35  0-1503.19@
 
mxvalb                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1470.39$  0-1433.44  0-1490.41  0-1498.41
 
npos                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1481.7@  0-1489.21  0-1490.26  0-1495.35  0-1497.26  0-1498.31  0-1503.35  0-1507.11@  0-1507.19
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1469.31$  0-1432.37
 
** fi7517   === End of Compilation 8 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
       1515 |      SUBROUTINE FI7518 (IRET,IWORK,NPTS,ISTRTA,INRNGA,INRNGB,
       1516 |     *                          MAXA,MINA,LWIDEA,MXVALA)
       1517 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
       1518 |C                .      .    .                                       .
       1519 |C SUBPROGRAM:    FI7518      SCAN FORWARD
       1520 |C   PRGMMR: CAVANAUGH        ORG: W/NMC42    DATE: 94-01-21
       1521 |C
       1522 |C ABSTRACT: SCAN FORWARD FROM START OF BLOCK B TOWARDS END OF BLOCK B
       1523 |C           IF NEXT POINT UNDER TEST FORCES A LARGER MAXVALA THEN
       1524 |C           TERMINATE INDICATING LAST POINT TESTED FOR INCLUSION
       1525 |C           INTO BLOCK A.
       1526 |C
       1527 |C PROGRAM HISTORY LOG:
       1528 |C   94-01-21  CAVANAUGH
       1529 |C   95-10-31  IREDELL     REMOVED SAVES AND PRINTS
       1530 |C   98-06-17  IREDELL     REMOVED ALTERNATE RETURN
       1531 |C
       1532 |C USAGE:    CALL FI7518 (IRET,IWORK,NPTS,ISTRTA,INRNGA,INRNGB,
       1533 |C     *                          MAXA,MINA,LWIDEA,MXVALA)
       1534 |C   INPUT ARGUMENT LIST:
       1535 |C     IFLD     -
       1536 |C     JSTART   -
       1537 |C     NPTS     -
       1538 |C
       1539 |C   OUTPUT ARGUMENT LIST:      (INCLUDING WORK ARRAYS)
       1540 |C     IRET     -
       1541 |C     JLAST    -
       1542 |C     MAX      -
       1543 |C     MIN      -
       1544 |C     LWIDTH   - NUMBER OF BITS TO CONTAIN MAX DIFF
       1545 |C
       1546 |C REMARKS: SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
       1547 |C
       1548 |C ATTRIBUTES:
       1549 |C   LANGUAGE: IBM VS FORTRAN 77, CRAY CFT77 FORTRAN
       1550 |C   MACHINE:  HDS, CRAY C916/256, Y-MP8/64, Y-MP EL92/256
       1551 |C
       1552 |C$$$
       1553 |      INTEGER        IWORK(*),NPTS,ISTRTA,INRNGA
       1554 |      INTEGER        MAXA,MINA,LWIDEA,MXVALA
       1555 |      INTEGER        IBITS(31)
       1556 |C
       1557 |      DATA           IBITS/1,3,7,15,31,63,127,255,511,1023,2047,
       1558 |     *               4095,8191,16383,32767,65535,131071,262143,
       1559 |     *               524287,1048575,2097151,4194303,8388607,
       1560 |     *               16777215,33554431,67108863,134217727,268435455,
       1561 |     *               536870911,1073741823,2147483647/
       1562 |C  ----------------------------------------------------------------
       1563 |      IRET=0
       1564 |C     PRINT *,'          FI7518'
       1565 |      NPOS  = ISTRTA + INRNGA
       1566 |      ITST  = 0
       1567 |C
       1568 | 1000 CONTINUE
       1569 |      ITST  = ITST + 1
       1570 |      IF (ITST.LE.INRNGB) THEN
       1571 |C         PRINT *,'TRY NPOS',NPOS,IWORK(NPOS),MAXA,MINA
       1572 |          IF (IWORK(NPOS).GT.MAXA) THEN
       1573 |              IF ((IWORK(NPOS)-MINA).GT.MXVALA) THEN
       1574 |C                 PRINT *,'FI7518A -',ITST,' RANGE EXCEEDS MAX'
       1575 |                  IRET=1
       1576 |                  RETURN
       1577 |              ELSE
       1578 |                  MAXA    = IWORK(NPOS)
       1579 |              END IF
       1580 |          ELSE IF (IWORK(NPOS).LT.MINA) THEN
       1581 |              IF ((MAXA-IWORK(NPOS)).GT.MXVALA) THEN
       1582 |C                 PRINT *,'FI7518B -',ITST,' RANGE EXCEEDS MAX'
       1583 |                  IRET=1
       1584 |                  RETURN
       1585 |              ELSE
       1586 |                  MINA    = IWORK(NPOS)
       1587 |              END IF
       1588 |          END IF
       1589 |          INRNGA  = INRNGA + 1
       1590 |C         PRINT *,'               ',ITST,INRNGA
       1591 |          NPOS  = NPOS +1
       1592 |          GO TO 1000
       1593 |      END IF
       1594 |C  ----------------------------------------------------------------
       1595 | 9000 CONTINUE
       1596 |      RETURN
       1597 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
fi7518                           Subroutine
                                 0-1515.18$
 
ibits                            Static, Integer(4) (1:31), Offset: 0, Alignment: full word
                                 0-1555.22$  0-1557.22*
 
inrnga                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1553.43$  0-1515.49  0-1565.24  0-1589.11@  0-1589.21
 
inrngb                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1515.56  0-1570.19
 
iret                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1515.26  0-1563.7@  0-1575.19@  0-1583.19@
 
istrta                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1553.36$  0-1515.42  0-1565.15
 
itst                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1566.7@  0-1569.7@  0-1569.15  0-1570.11
 
iwork                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-1553.22$  0-1515.31  0-1572.15  0-1573.20  0-1578.29  0-1580.20  0-1581.25  0-1586.29
 
lwidea                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1554.32$  0-1516.43
 
maxa                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1554.22$  0-1516.33  0-1572.30  0-1578.19@  0-1581.20
 
mina                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1554.27$  0-1516.38  0-1573.32  0-1580.35  0-1586.19@
 
mxvala                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1554.39$  0-1516.50  0-1573.41  0-1581.41
 
npos                             Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-1565.7@  0-1572.21  0-1573.26  0-1578.35  0-1580.26  0-1581.31  0-1586.35  0-1591.11@  0-1591.19
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1553.31$  0-1515.37
 
** fi7518   === End of Compilation 9 ===
 
>>>>> COMPILATION UNIT EPILOGUE SECTION <<<<<
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
>>>>> FILE TABLE SECTION <<<<<
 
 
                                       FILE CREATION        FROM
FILE NO   FILENAME                    DATE       TIME       FILE    LINE
     0    w3fi75.f                    11/27/06   09:25:36
 
 
>>>>> COMPILATION EPILOGUE SECTION <<<<<
 
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
 
    Source records read.......................................    1597
1501-510  Compilation successful for file w3fi75.f.
1501-543  Object file created.
