IBM XL Fortran Enterprise Edition V10.1 for AIX (5724-M13)  Version 10.01.0000.0002 --- /gpfs/m/nco/ops/nwpara/sorc/aqm_makeprecip_138.fd/w3fi72.f 11/27/06 09:54:24
 
>>>>> OPTIONS SECTION <<<<<
***   Options In Effect   ***
  
         ==  On / Off Options  ==
         CR              DBG             DDIM            ESCAPE
         FULLPATH        I4              INLGLUE         NOLIBESSL
         NOLIBPOSIX      OBJECT          SOURCE          STDFRAMEWORK
         STRICT          SWAPOMP         THREADED        UNWIND
         NOZEROSIZE
  
         ==  Options Of Integer Type ==
         FIXED(72)             MAXMEM(-1)            OPTIMIZE(2)
         SPILLSIZE(548)        STACKTEMP(0)
  
         ==  Options Of Character Type  ==
         64(LARGETYPE)         ALIAS(STD,INTPTR)     ALIGN(BINDC(POWER),STRUCT(NATURAL))
         ARCH(PWR5X)           ATTR()                AUTODBL(NONE)
         DIRECTIVE(IBM*,IBMT)  ENUM()                FLAG(I,I)
         FLOAT(RNDSNGL,MAF,FOLD,RNGCHK)
         HALT(S)               IEEE(NEAR)            INTSIZE(4)
         LANGLVL(EXTENDED)     POSITION(APPENDOLD)   REALSIZE(4)
         NOSAVE()              TUNE(PWR5)            UNROLL(AUTO)
         XREF(FULL)            XLF77(NOLEADZERO,GEDIT77,NOBLANKPAD,OLDBOZ,INTARG,INTXOR,PERSISTENT,SOFTEOF)
         XLF90(NOSIGNEDZERO,NOAUTODEALLOC)
  
>>>>> SOURCE SECTION <<<<<
          1 |      SUBROUTINE W3FI72(ITYPE,FLD,IFLD,IBITL,
          2 |     &                  IPFLAG,ID,PDS,
          3 |     &                  IGFLAG,IGRID,IGDS,ICOMP,
          4 |     &                  IBFLAG,IBMAP,IBLEN,IBDSFL,
          5 |     &                  NPTS,KBUF,ITOT,JERR)
          6 |C$$$  SUBPROGRAM DOCUMENTATION BLOCK
          7 |C                .      .    .                                       .
          8 |C SUBPROGRAM:  W3FI72        MAKE A COMPLETE GRIB MESSAGE
          9 |C   PRGMMR: FARLEY           ORG: NMC421      DATE:94-11-22
         10 |C
         11 |C ABSTRACT: MAKES A COMPLETE GRIB MESSAGE FROM A USER SUPPLIED
         12 |C   ARRAY OF FLOATING POINT OR INTEGER DATA.  THE USER HAS THE
         13 |C   OPTION OF SUPPLYING THE PDS OR AN INTEGER ARRAY THAT WILL BE
         14 |C   USED TO CREATE A PDS (WITH W3FI68).  THE USER MUST ALSO
         15 |C   SUPPLY OTHER NECESSARY INFO; SEE USAGE SECTION BELOW.
         16 |C
         17 |C PROGRAM HISTORY LOG:
         18 |C   91-05-08  R.E.JONES
         19 |C   92-07-01  M. FARLEY    ADDED GDS AND BMS LOGIC.  PLACED EXISTING
         20 |C                          LOGIC FOR BDS IN A ROUTINE.
         21 |C   92-10-02  R.E.JONES    ADD ERROR EXIT FOR W3FI73
         22 |C   93-04-30  R.E.JONES    REPLACE DO LOOPS TO MOVE CHARACTER DATA
         23 |C                          WITH XMOVEX, USE XSTORE TO ZERO CHARACTER
         24 |C                          ARRAY. MAKE CHANGE SO FLAT FIELD WILL PACK.
         25 |C   93-08-06  CAVANAUGH    MODIFIED CALL TO W3FI75
         26 |C   93-10-26  CAVANAUGH    ADDED CODE TO RESTORE INPUT FIELD TO ORIGINAL
         27 |C                          VALUES IF D-SCALE NOT 0
         28 |C   94-01-27  CAVANAUGH    ADDED IGDS ARRAY IN CALL TO W3FI75 TO PROVIDE
         29 |C                          INFORMATION FOR BOUSTROPHEDONIC PROCESSING
         30 |C   94-03-03  CAVANAUGH    INCREASED SIZE OF GDS ARRAY FOR THIN GRIDS
         31 |C   94-05-16  FARLEY       CLEANED UP DOCUMENTATION
         32 |C   94-11-10  FARLEY       INCREASED SIZE OF PFLD/IFLD ARRARYS FROM
         33 |C                          100K TO 260K FOR .5 DEGREE SST ANAL FIELDS
         34 |C   94-12-04  R.E.JONES    CHANGE DOCUMENT FOR IPFLAG.
         35 |C   95-10-31  IREDELL      REMOVED SAVES AND PRINTS
         36 |C   98-05-19  Gilbert      Increased array dimensions to handle grids
         37 |C                          of up to 500,000 grid points.
         38 |C   95-10-31  IREDELL      GENERALIZED WORD SIZE
         39 |C   98-12-21  Gilbert      Replaced Function ICHAR with mova2i.
         40 |C   99-02-01  Gilbert      Changed the method of zeroing out array KBUF.
         41 |C                          the old method, using W3FI01 and XSTORE was
         42 |C                          incorrect with 4-byte integers and 8-byte reals.
         43 |C
         44 |C USAGE:  CALL W3FI72(ITYPE,FLD,IFLD,IBITL,
         45 |C        &            IPFLAG,ID,PDS,
         46 |C        &            IGFLAG,IGRID,IGDS,ICOMP,
         47 |C        &            IBFLAG,IBMAP,IBLEN,IBDSFL,
         48 |C        &            IBDSFL,
         49 |C        &            NPTS,KBUF,ITOT,JERR)
         50 |C
         51 |C   INPUT ARGUMENT LIST:
         52 |C     ITYPE    - 0 = FLOATING POINT DATA SUPPLIED IN ARRAY 'FLD'
         53 |C                1 = INTEGER DATA SUPPLIED IN ARRAY 'IFLD'
         54 |C     FLD      - REAL ARRAY OF DATA (AT PROPER GRIDPOINTS) TO BE
         55 |C                CONVERTED TO GRIB FORMAT IF ITYPE=0.
         56 |C                SEE REMARKS #1 & 2.
         57 |C     IFLD     - INTEGER ARRAY OF DATA (AT PROPER GRIDPOINTS) TO BE
         58 |C                CONVERTED TO GRIB FORMAT IF ITYPE=1.
         59 |C                SEE REMARKS #1 & 2.
         60 |C     IBITL    - 0 = COMPUTER COMPUTES LENGTH FOR PACKING DATA FROM
         61 |C                    POWER OF 2 (NUMBER OF BITS) BEST FIT OF DATA
         62 |C                    USING 'VARIABLE' BIT PACKER W3FI58.
         63 |C                8, 12, ETC. COMPUTER RESCALES DATA TO FIT INTO THAT
         64 |C                    'FIXED' NUMBER OF BITS USING W3FI59.
         65 |C                SEE REMARKS #3.
         66 |C
         67 |C     IPFLAG   - 0 = MAKE PDS FROM USER SUPPLIED ARRAY (ID)
         68 |C                1 = USER SUPPLYING PDS
         69 |C                NOTE: IF PDS IS GREATER THAN 30, USE IPLFAG=1.
         70 |C                THE USER COULD CALL W3FI68 BEFORE HE CALLS
         71 |C                W3FI72. THIS WOULD MAKE THE FIRST 30 BYTES OF
         72 |C                THE PDS, USER THEN WOULD MAKE BYTES AFTER 30.
         73 |C     ID       - INTEGER ARRAY OF  VALUES THAT W3FI68 WILL USE
         74 |C                TO MAKE AN EDITION 1 PDS IF IPFLAG=0.  (SEE THE
         75 |C                DOCBLOCK FOR W3FI68 FOR LAYOUT OF ARRAY)
         76 |C     PDS      - CHARACTER ARRAY OF VALUES (VALID PDS SUPPLIED
         77 |C                BY USER) IF IPFLAG=1. LENGTH MAY EXCEED 28 BYTES
         78 |C                (CONTENTS OF BYTES BEYOND 28 ARE PASSED
         79 |C                THROUGH UNCHANGED).
         80 |C
         81 |C     IGFLAG   - 0 = MAKE GDS BASED ON 'IGRID' VALUE.
         82 |C                1 = MAKE GDS FROM USER SUPPLIED INFO IN 'IGDS'
         83 |C                    AND 'IGRID' VALUE.
         84 |C                SEE REMARKS #4.
         85 |C     IGRID    - #   = GRID IDENTIFICATION (TABLE B)
         86 |C                255 = IF USER DEFINED GRID; IGDS MUST BE SUPPLIED
         87 |C                      AND IGFLAG MUST =1.
         88 |C     IGDS     - INTEGER ARRAY CONTAINING USER GDS INFO (SAME
         89 |C                FORMAT AS SUPPLIED BY W3FI71 - SEE DOCKBLOCK FOR
         90 |C                LAYOUT) IF IGFLAG=1.
         91 |C     ICOMP    - RESOLUTION AND COMPONENT FLAG FOR BIT 5 OF GDS(17)
         92 |C                0 = EARTH ORIENTED WINDS
         93 |C                1 = GRID ORIENTED WINDS
         94 |C
         95 |C     IBFLAG   - 0 = MAKE BIT MAP FROM USER SUPPLIED DATA
         96 |C                # = BIT MAP PREDEFINED BY CENTER
         97 |C                SEE REMARKS #5.
         98 |C     IBMAP    - INTEGER ARRAY CONTAINING BIT MAP
         99 |C     IBLEN    - LENGTH OF BIT MAP WILL BE USED TO VERIFY LENGTH
        100 |C                OF FIELD (ERROR IF IT DOESN'T MATCH).
        101 |C
        102 |C     IBDSFL   - INTEGER ARRAY CONTAINING TABLE 11 FLAG INFO
        103 |C                BDS OCTET 4:
        104 |C                (1) 0 = GRID POINT DATA
        105 |C                    1 = SPHERICAL HARMONIC COEFFICIENTS
        106 |C                (2) 0 = SIMPLE PACKING
        107 |C                    1 = SECOND ORDER PACKING
        108 |C                (3) ... SAME VALUE AS 'ITYPE'
        109 |C                    0 = ORIGINAL DATA WERE FLOATING POINT VALUES
        110 |C                    1 = ORIGINAL DATA WERE INTEGER VALUES
        111 |C                (4) 0 = NO ADDITIONAL FLAGS AT OCTET 14
        112 |C                    1 = OCTET 14 CONTAINS FLAG BITS 5-12
        113 |C                (5) 0 = RESERVED - ALWAYS SET TO 0
        114 |C         BYTE 6 OPTION 1 NOT AVAILABLE (AS OF 5-16-93)
        115 |C                (6) 0 = SINGLE DATUM AT EACH GRID POINT
        116 |C                    1 = MATRIX OF VALUES AT EACH GRID POINT
        117 |C         BYTE 7 OPTION 0 WITH SECOND ORDER PACKING N/A (AS OF 5-16-93)
        118 |C                (7) 0 = NO SECONDARY BIT MAPS
        119 |C                    1 = SECONDARY BIT MAPS PRESENT
        120 |C                (8) 0 = SECOND ORDER VALUES HAVE CONSTANT WIDTH
        121 |C                    1 = SECOND ORDER VALUES HAVE DIFFERENT WIDTHS
        122 |C
        123 |C   OUTPUT ARGUMENT LIST:
        124 |C     NPTS     - NUMBER OF GRIDPOINTS IN ARRAY FLD OR IFLD
        125 |C     KBUF     - ENTIRE GRIB MESSAGE ('GRIB' TO '7777')
        126 |C                EQUIVALENCE TO INTEGER ARRAY TO MAKE SURE IT
        127 |C                IS ON WORD BOUNARY.
        128 |C     ITOT     - TOTAL LENGTH OF GRIB MESSAGE IN BYTES
        129 |C     JERR     - = 0, COMPLETED MAKING GRIB FIELD WITHOUT ERROR
        130 |C                  1, IPFLAG NOT 0 OR 1
        131 |C                  2, IGFLAG NOT 0 OR 1
        132 |C                  3, ERROR CONVERTING IEEE F.P. NUMBER TO IBM370 F.P.
        133 |C                  4, W3FI71 ERROR/IGRID NOT DEFINED
        134 |C                  5, W3FK74 ERROR/GRID REPRESENTATION TYPE NOT VALID
        135 |C                  6, GRID TOO LARGE FOR PACKER DIMENSION ARRAYS
        136 |C                     SEE AUTOMATION DIVISION FOR REVISION!
        137 |C                  7, LENGTH OF BIT MAP NOT EQUAL TO SIZE OF FLD/IFLD
        138 |C                  8, W3FI73 ERROR, ALL VALUES IN IBMAP ARE ZERO
        139 |C
        140 |C   OUTPUT FILES:
        141 |C     FT06F001 - STANDARD FORTRAN OUTPUT PRINT FILE
        142 |C
        143 |C   SUBPROGRAMS CALLED:
        144 |C     LIBRARY:
        145 |C       W3LIB    - W3FI58, W3FI59, W3FI68, W3FI71, W3FI73, W3FI74
        146 |C                  W3FI75, W3FI76
        147 |C       FORTRAN 90 INTRINSIC - BIT_SIZE
        148 |C
        149 |C REMARKS:
        150 |C   1)  IF BIT MAP TO BE INCLUDED IN MESSAGE, NULL DATA SHOULD
        151 |C       BE INCLUDED IN FLD OR IFLD.  THIS ROUTINE WILL TAKE CARE
        152 |C       OF 'DISCARDING' ANY NULL DATA BASED ON THE BIT MAP.
        153 |C   2)  UNITS MUST BE THOSE IN GRIB DOCUMENTATION:  NMC O.N. 388
        154 |C       OR WMO PUBLICATION 306.
        155 |C   3)  IN EITHER CASE, INPUT NUMBERS WILL BE MULTIPLIED BY
        156 |C       '10 TO THE NTH' POWER FOUND IN ID(25) OR PDS(27-28),
        157 |C       THE D-SCALING FACTOR, PRIOR TO BINARY PACKING.
        158 |C   4)  ALL NMC PRODUCED GRIB FIELDS WILL HAVE A GRID DEFINITION
        159 |C       SECTION INCLUDED IN THE GRIB MESSAGE.  ID(6) WILL BE
        160 |C       SET TO '1'.
        161 |C       - GDS WILL BE BUILT BASED ON GRID NUMBER (IGRID), UNLESS
        162 |C         IGFLAG=1 (USER SUPPLYING IGDS).  USER MUST STILL SUPPLY
        163 |C         IGRID EVEN IF IGDS PROVIDED.
        164 |C   5)  IF BIT MAP USED THEN ID(7) OR PDS(8) MUST INDICATE THE
        165 |C       PRESENCE OF A BIT MAP.
        166 |C   6)  ARRAY KBUF SHOULD BE EQUIVALENCED TO AN INTEGER VALUE OR
        167 |C       ARRAY TO MAKE SURE IT IS ON A WORD BOUNDARY.
        168 |C   7)  SUBPROGRAM CAN BE CALLED FROM A MULTIPROCESSING ENVIRONMENT.
        169 |C
        170 |C ATTRIBUTES:
        171 |C   LANGUAGE: FORTRAN 90
        172 |C
        173 |C$$$
        174 |C
        175 |      REAL            FLD(*)
        176 |C
        177 |      INTEGER         IBDSFL(*)
        178 |      INTEGER         IBMAP(*)
        179 |      INTEGER         ID(*)
        180 |      INTEGER         IFLD(*)
        181 |      INTEGER         IGDS(*)
        182 |      INTEGER,ALLOCATABLE:: IPFLD(:)
        183 |      INTEGER         IB(4)
        184 |C
        185 |      CHARACTER * 1   BDS11(11)
        186 |      CHARACTER * 1   KBUF(*)
        187 |      CHARACTER * 1   PDS(*)
        188 |      CHARACTER * 1   GDS(200)
        189 |      CHARACTER(1),ALLOCATABLE:: BMS(:)
        190 |      CHARACTER(1),ALLOCATABLE:: PFLD(:)
        191 |      CHARACTER * 1   SEVEN
        192 |      CHARACTER * 1   ZERO
        193 |C
        194 |C
        195 |C   ASCII REP OF  /'G', 'R', 'I', 'B'/
        196 |C
        197 |      DATA  IB    / 71,  82,  73,  66/
        198 |C
        199 |      IER    = 0
        200 |      IBERR  = 0
        201 |      JERR   = 0
        202 |      IGRIBL = 8
        203 |      IPDSL  = 0
        204 |      LENGDS = 0
        205 |      LENBMS = 0
        206 |      LENBDS = 0
        207 |      ITOSS  = 0
        208 |C
        209 |C$           1.0   PRODUCT DEFINITION SECTION(PDS).
        210 |C
        211 |C   SET ID(6) TO 1 ...OR... MODIFY PDS(8) ...
        212 |C      REGARDLESS OF USER SPECIFICATION...
        213 |C   NMC GRIB FIELDS WILL ALWAYS HAVE A GDS
        214 |C
        215 |      IF (IPFLAG .EQ.0) THEN
        216 |        ID(6) = 1
        217 |        CALL W3FI68(ID,PDS)
        218 |      ELSE IF (IPFLAG .EQ. 1) THEN
        219 |        IF (IAND(mova2i(PDS(8)),64) .EQ. 64) THEN
        220 |C         BOTH GDS AND BMS
        221 |          PDS(8) = CHAR(192)
        222 |        ELSE IF (mova2i(PDS(8)) .EQ. 0) THEN
        223 |C         GDS ONLY
        224 |          PDS(8) = CHAR(128)
        225 |        END IF
        226 |        CONTINUE
        227 |      ELSE
        228 |C       PRINT *,' W3FI72 ERROR, IPFLAG IS NOT 0 OR 1 IPFLAG = ',IPFLAG
        229 |        JERR = 1
        230 |        GO TO 900
        231 |      END IF
        232 |C
        233 |C     GET LENGTH OF PDS
        234 |C
        235 |      IPDSL = mova2i(PDS(1)) * 65536 + mova2i(PDS(2)) * 256 +
        236 |     &        mova2i(PDS(3))
        237 |C
        238 |C$           2.0   GRID DEFINITION SECTION (GDS).
        239 |C
        240 |C     IF IGFLAG=1 THEN USER IS SUPPLYING THE IGDS INFORMATION
        241 |C
        242 |      IF (IGFLAG .EQ. 0) THEN
        243 |        CALL W3FI71(IGRID,IGDS,IGERR)
        244 |        IF (IGERR .EQ. 1) THEN
        245 |C         PRINT *,' W3FI71 ERROR, GRID TYPE NOT DEFINED...',IGRID
        246 |          JERR = 4
        247 |          GO TO 900
        248 |        END IF
        249 |      END IF
        250 |      IF (IGFLAG .EQ. 0  .OR.  IGFLAG .EQ.1) THEN
        251 |        CALL W3FI74(IGDS,ICOMP,GDS,LENGDS,NPTS,IGERR)
        252 |        IF (IGERR .EQ. 1) THEN
        253 |C         PRINT *,' W3FI74 ERROR, GRID REP TYPE NOT VALID...',IGDS(3)
        254 |          JERR = 5
        255 |          GO TO 900
        256 |        ELSE
        257 |        END IF
        258 |      ELSE
        259 |C       PRINT *,' W3FI72 ERROR, IGFLAG IS NOT 0 OR 1 IGFLAG = ',IGFLAG
        260 |        JERR = 2
        261 |        GO TO 900
        262 |      END IF
        263 |C
        264 |C$           3.0   BIT MAP SECTION (BMS).
        265 |C
        266 |C     SET ITOSS=1 IF BITMAP BEING USED.  W3FI75 WILL TOSS DATA
        267 |C     PRIOR TO PACKING.  LATER CODING WILL BE NEEDED WHEN THE
        268 |C     'PREDEFINED' GRIDS ARE FINALLY 'DEFINED'.
        269 |C
        270 |      IF (mova2i(PDS(8)) .EQ. 64 .OR.
        271 |     &    mova2i(PDS(8)) .EQ. 192)   THEN
        272 |        ITOSS = 1
        273 |        IF (IBFLAG .EQ. 0) THEN
        274 |          IF (IBLEN .NE. NPTS) THEN
        275 |C           PRINT *,' W3FI72 ERROR, IBLEN .NE. NPTS = ',IBLEN,NPTS
        276 |            JERR = 7
        277 |            GO TO 900
        278 |          END IF
        279 |          ALLOCATE(BMS(NPTS/8+6))
        280 |          CALL W3FI73(IBFLAG,IBMAP,IBLEN,BMS,LENBMS,IER)
        281 |          IF (IER .NE. 0) THEN
        282 |C           PRINT *,' W3FI73 ERROR, IBMAP VALUES ARE ALL ZERO'
        283 |            JERR = 8
        284 |            GO TO 900
        285 |          END IF
        286 |        ELSE
        287 |C         PRINT *,'   BIT MAP PREDEFINED BY CENTER, IBFLAG = ',IBFLAG
        288 |        END IF
        289 |      END IF
        290 |C
        291 |C$           4.0   BINARY DATA SECTION (BDS).
        292 |C
        293 |C$           4.1   SCALE THE DATA WITH D-SCALE FROM PDS(27-28)
        294 |C
        295 |      JSCALE = mova2i(PDS(27)) * 256 + mova2i(PDS(28))
        296 |      IF (IAND(JSCALE,32768).NE.0) THEN
        297 |        JSCALE = - IAND(JSCALE,32767)
        298 |      END IF
        299 |      SCALE  = 10.0 ** JSCALE
        300 |      IF (ITYPE .EQ. 0) THEN
        301 |        DO 410 I = 1,NPTS
        302 |          FLD(I) = FLD(I) * SCALE
        303 |  410   CONTINUE
        304 |      ELSE
        305 |        DO 411 I = 1,NPTS
        306 |          IFLD(I) = NINT(FLOAT(IFLD(I)) * SCALE)
        307 |  411   CONTINUE
        308 |      END IF
        309 |C
        310 |C$           4.2   CALL W3FI75 TO PACK DATA AND MAKE BDS.
        311 |C
        312 |      ALLOCATE(PFLD(NPTS*4))
        313 |C
        314 |      IF(IBDSFL(2).NE.0) THEN
        315 |        ALLOCATE(IPFLD(NPTS*32/BIT_SIZE(1)+1))
        316 |        IPFLD=0
        317 |      ENDIF
        318 |C
        319 |      CALL W3FI75(IBITL,ITYPE,ITOSS,FLD,IFLD,IBMAP,IBDSFL,
        320 |     &         NPTS,BDS11,IPFLD,PFLD,LEN,LENBDS,IBERR,PDS,IGDS)
        321 |C
        322 |      IF(IBDSFL(2).NE.0) THEN
        323 |        CALL XMOVEX(PFLD,IPFLD,NPTS*4)
        324 |        DEALLOCATE(IPFLD)
        325 |      ENDIF
        326 |C
        327 |        IF (IBERR .EQ. 1) THEN
        328 |          JERR = 3
        329 |          GO TO 900
        330 |        END IF
        331 |C            4.3   IF D-SCALE NOT 0, RESCALE INPUT FIELD TO
        332 |C                   ORIGINAL VALUE
        333 |C
        334 |      IF (JSCALE.NE.0) THEN
        335 |          DSCALE = 1.0 / SCALE
        336 |          IF (ITYPE.EQ.0) THEN
        337 |              DO 412 I = 1, NPTS
        338 |                  FLD(I)  = FLD(I) * DSCALE
        339 |  412         CONTINUE
        340 |          ELSE
        341 |              DO 413 I = 1, NPTS
        342 |                  FLD(I)  = NINT(FLOAT(IFLD(I)) * DSCALE)
        343 |  413         CONTINUE
        344 |          END IF
        345 |      END IF
        346 |C
        347 |C$           5.0   OUTPUT SECTION.
        348 |C
        349 |C$           5.1   ZERO OUT THE OUTPUT ARRAY KBUF.
        350 |C
        351 |      ZERO    = CHAR(00)
        352 |      ITOT    = IGRIBL + IPDSL + LENGDS + LENBMS + LENBDS + 4
        353 |C     PRINT *,'IGRIBL  =',IGRIBL
        354 |C     PRINT *,'IPDSL   =',IPDSL
        355 |C     PRINT *,'LENGDS  =',LENGDS
        356 |C     PRINT *,'LENBMS  =',LENBMS
        357 |C     PRINT *,'LENBDS  =',LENBDS
        358 |C     PRINT *,'ITOT    =',ITOT
        359 |      KBUF(1:ITOT)=ZERO
        360 |C
        361 |C$           5.2   MOVE SECTION 0 - 'IS' INTO KBUF (8 BYTES).
        362 |C
        363 |      ISTART  = 0
        364 |      DO 520 I = 1,4
        365 |        KBUF(I) = CHAR(IB(I))
        366 |  520 CONTINUE
        367 |C
        368 |      KBUF(5) = CHAR(MOD(ITOT / 65536,256))
        369 |      KBUF(6) = CHAR(MOD(ITOT /   256,256))
        370 |      KBUF(7) = CHAR(MOD(ITOT        ,256))
        371 |      KBUF(8) = CHAR(1)
        372 |C
        373 |C$           5.3   MOVE SECTION 1 - 'PDS' INTO KBUF (28 BYTES).
        374 |C
        375 |      ISTART  = ISTART + IGRIBL
        376 |      IF (IPDSL.GT.0) THEN
        377 |        CALL XMOVEX(KBUF(ISTART+1),PDS,IPDSL)
        378 |      ELSE
        379 |C       PRINT *,'LENGTH OF PDS LESS OR EQUAL 0, IPDSL = ',IPDSL
        380 |      END IF
        381 |C
        382 |C$           5.4   MOVE SECTION 2 - 'GDS' INTO KBUF.
        383 |C
        384 |      ISTART  = ISTART + IPDSL
        385 |      IF (LENGDS .GT. 0) THEN
        386 |        CALL XMOVEX(KBUF(ISTART+1),GDS,LENGDS)
        387 |      END IF
        388 |C
        389 |C$           5.5   MOVE SECTION 3 - 'BMS' INTO KBUF.
        390 |C
        391 |      ISTART  = ISTART + LENGDS
        392 |      IF (LENBMS .GT. 0) THEN
        393 |        CALL XMOVEX(KBUF(ISTART+1),BMS,LENBMS)
        394 |      END IF
        395 |C
        396 |C$           5.6   MOVE SECTION 4 - 'BDS' INTO KBUF.
        397 |C
        398 |C$                 MOVE THE FIRST 11 OCTETS OF THE BDS INTO KBUF.
        399 |C
        400 |      ISTART  = ISTART + LENBMS
        401 |      CALL XMOVEX(KBUF(ISTART+1),BDS11,11)
        402 |C
        403 |C$                 MOVE THE PACKED DATA INTO THE KBUF
        404 |C
        405 |      ISTART  = ISTART + 11
        406 |      IF (LEN.GT.0) THEN
        407 |        CALL XMOVEX(KBUF(ISTART+1),PFLD,LEN)
        408 |      END IF
        409 |C
        410 |C$                 ADD '7777' TO END OFF KBUF
        411 |C   NOTE THAT THESE 4 OCTETS NOT INCLUDED IN ACTUAL SIZE OF BDS.
        412 |C
        413 |      SEVEN  = CHAR(55)
        414 |      ISTART = ITOT - 4
        415 |      DO 562 I = 1,4
        416 |        KBUF(ISTART+I) = SEVEN
        417 | 562  CONTINUE
        418 |C
        419 | 900  CONTINUE
        420 |      IF(ALLOCATED(BMS)) DEALLOCATE(BMS)
        421 |      IF(ALLOCATED(PFLD)) DEALLOCATE(PFLD)
        422 |      RETURN
        423 |      END
 
>>>>> ATTRIBUTE AND CROSS REFERENCE SECTION <<<<<
 
 
 
IDENTIFIER NAME                  CROSS REFERENCE AND ATTRIBUTES
 
allocated                        Pure Intrinsic
                                 0-420.10  0-421.10
 
bds11                            Automatic, Character(1) (1:11), Offset: 0, Alignment: full word
                                 0-185.23$  0-320.21  0-401.34
 
bit_size                         Pure Intrinsic
                                 0-315.32
 
bms                              Allocatable, Controlled, Character(1) (:), Offset: 0, Alignment: full word
                                 0-189.34$  0-279.20  0-280.42  0-393.36  0-420.20  0-420.37
 
char                             Pure Intrinsic
                                 0-221.20  0-224.20  0-351.17  0-365.19  0-368.17  0-369.17  0-370.17  0-371.17  0-413.16
 
dscale                           Automatic, Real(4), Offset: 0, Alignment: full word
                                 0-335.11@  0-338.38  0-342.51
 
fld                              Reference argument, Real(4) (1:*), Offset: 0, Alignment: full word
                                 0-175.23$  0-1.31  0-302.11@  0-302.20  0-319.37  0-338.19@  0-338.29  0-342.19@
 
float                            Pure Intrinsic
                                 0-306.26  0-342.34
 
gds                              Automatic, Character(1) (1:200), Offset: 0, Alignment: full word
                                 0-188.23$  0-251.32  0-386.36
 
i                                Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-301.16@  0-302.15  0-302.24  0-305.16@  0-306.16  0-306.37  0-337.22@  0-338.23  0-338.33
                                 0-341.22@  0-342.23  0-342.45  0-364.14@  0-365.14  0-365.27  0-415.14@  0-416.21
 
iand                             Pure Intrinsic
                                 0-219.13  0-296.11  0-297.20
 
ib                               Static, Integer(4) (1:4), Offset: 0, Alignment: full word
                                 0-183.23$  0-197.13*  0-365.24
 
ibdsfl                           Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-177.23$  0-4.44  0-314.10  0-319.52  0-322.10
 
iberr                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-200.7@  0-320.49  0-327.13
 
ibflag                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-4.25  0-273.13  0-280.23
 
ibitl                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1.40  0-319.19
 
iblen                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-4.38  0-274.15  0-280.36
 
ibmap                            Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-178.23$  0-4.32  0-280.30  0-319.46
 
icomp                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-3.43  0-251.26
 
id                               Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-179.23$  0-2.32  0-216.9@  0-217.21
 
ier                              Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-199.7@  0-280.53  0-281.15
 
ifld                             Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-180.23$  0-1.35  0-306.11@  0-306.32  0-319.41  0-342.40
 
igds                             Reference argument, Integer(4) (1:*), Offset: 0, Alignment: full word
                                 0-181.23$  0-3.38  0-243.27  0-251.21  0-320.59
 
igerr                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-243.32  0-244.13  0-251.48  0-252.13
 
igflag                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-3.25  0-242.11  0-250.11  0-250.32
 
igribl                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-202.7@  0-352.17  0-375.26
 
igrid                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-3.32  0-243.21
 
ipdsl                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-203.7@  0-235.7@  0-352.26  0-376.11  0-377.40  0-384.26
 
ipflag                           Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-2.25  0-215.11  0-218.16
 
ipfld                            Allocatable, Controlled, Integer(4) (:), Offset: 0, Alignment: full word
                                 0-182.29$  0-315.18  0-316.9@  0-320.27  0-323.26  0-324.20
 
istart                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-363.7@  0-375.7@  0-375.17  0-377.26  0-384.7@  0-384.17  0-386.26  0-391.7@  0-391.17  0-393.26
                                 0-400.7@  0-400.17  0-401.24  0-405.7@  0-405.17  0-407.26  0-414.7@  0-416.14
 
itoss                            Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-207.7@  0-272.9@  0-319.31
 
itot                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-5.35  0-352.7@  0-359.14  0-368.26  0-369.26  0-370.26  0-414.16
 
itype                            Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-1.25  0-300.11  0-319.25  0-336.15
 
jerr                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-5.40  0-201.7@  0-229.9@  0-246.11@  0-254.11@  0-260.9@  0-276.13@  0-283.13@  0-328.11@
 
jscale                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-295.7@  0-296.16  0-297.9@  0-297.25  0-299.24  0-334.11
 
kbuf                             Reference argument, Character(1) (1:*), Offset: 0, Alignment: byte
                                 0-186.23$  0-5.30  0-359.7@  0-365.9@  0-368.7@  0-369.7@  0-370.7@  0-371.7@  0-377.21  0-386.21
                                 0-393.21  0-401.19  0-407.21  0-416.9@
 
len                              Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-320.38  0-406.11  0-407.41
 
lenbds                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-206.7@  0-320.42  0-352.52
 
lenbms                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-205.7@  0-280.46  0-352.43  0-392.11  0-393.40  0-400.26
 
lengds                           Automatic, Integer(4), Offset: 0, Alignment: full word
                                 0-204.7@  0-251.36  0-352.34  0-385.11  0-386.40  0-391.26
 
mod                              Pure Intrinsic
                                 0-368.22  0-369.22  0-370.22
 
mova2i                           External Function Integer(4)
                                 0-219.18  0-222.18  0-235.15  0-235.40  0-236.15  0-270.11  0-271.11  0-295.16  0-295.40
 
nint                             Pure Intrinsic
                                 0-306.21  0-342.29
 
npts                             Reference argument, Integer(4), Offset: 0, Alignment: full word
                                 0-5.25  0-251.43  0-274.26  0-279.24  0-301.22  0-305.22  0-312.21  0-315.24  0-320.16  0-323.32
                                 0-337.29  0-341.29
 
pds                              Reference argument, Character(1) (1:*), Offset: 0, Alignment: byte
                                 0-187.23$  0-2.35  0-217.24  0-219.25  0-221.11@  0-222.25  0-224.11@  0-235.22  0-235.47  0-236.22
                                 0-270.18  0-271.18  0-295.23  0-295.47  0-320.55  0-377.36
 
pfld                             Allocatable, Controlled, Character(1) (:), Offset: 0, Alignment: full word
                                 0-190.34$  0-312.16  0-320.33  0-323.21  0-407.36  0-421.20  0-421.38
 
scale                            Automatic, Real(4), Offset: 0, Alignment: full word
                                 0-299.7@  0-302.29  0-306.43  0-335.26
 
seven                            Automatic, Character(1), Offset: 0, Alignment: full word
                                 0-191.23$  0-413.7@  0-416.26
 
w3fi68                           External Subroutine
                                 0-217.14
 
w3fi71                           External Subroutine
                                 0-243.14
 
w3fi72                           Subroutine
                                 0-1.18$
 
w3fi73                           External Subroutine
                                 0-280.16
 
w3fi74                           External Subroutine
                                 0-251.14
 
w3fi75                           External Subroutine
                                 0-319.12
 
xmovex                           External Subroutine
                                 0-323.14  0-377.14  0-386.14  0-393.14  0-401.12  0-407.14
 
zero                             Automatic, Character(1), Offset: 0, Alignment: full word
                                 0-192.23$  0-351.7@  0-359.20
 
** w3fi72   === End of Compilation 1 ===
 
>>>>> FILE TABLE SECTION <<<<<
 
 
                                       FILE CREATION        FROM
FILE NO   FILENAME                    DATE       TIME       FILE    LINE
     0    w3fi72.f                    11/27/06   09:25:36
 
 
>>>>> COMPILATION EPILOGUE SECTION <<<<<
 
 
FORTRAN Summary of Diagnosed Conditions
 
TOTAL   UNRECOVERABLE  SEVERE       ERROR     WARNING    INFORMATIONAL
               (U)       (S)         (E)        (W)          (I)
    0           0         0           0          0            0
 
 
    Source records read.......................................     423
1501-510  Compilation successful for file w3fi72.f.
1501-543  Object file created.
